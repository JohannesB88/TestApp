<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>Note Now</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="NoteNow">

    <!-- Add Tone.js library -->
    <script src="js/tone.min.js"></script>

    <style>
        /* COLOR VARIABLES - Edit these to change color scheme */
        :root {

            
            /* Background Colors */
            --bg-primary: #f4f1e8;
            --bg-secondary: #fbf6ee;
            --bg-white: white;
            --bg-game-controls: rgb(244, 239, 230);
            --bg-piano-container: #333;
            --bg-hover-light: #e9ecef;
            --bg-overlay-dark: rgba(0,0,0,0.8);
            
            /* Text Colors */
            --text-primary: #333;
            --text-secondary: #666;
            --text-light-gray: #9d9d9d;
            --text-disabled: #ccc;
            --text-white: white;
            --text-black: black;
            --text-lives: rgba(97, 31, 31, 0.982);
            
            /* Button Colors */
            --btn-end-game: #853f33;
            --btn-end-game-hover: #a14747;
            --btn-start-game: #4e6386;
            --btn-start-game-hover: #f2e9cc;
            --btn-play-again: #4CAF50;
            
            /* Piano Key Colors */
            --key-white: white;
            --key-black: #333;
            --key-black-accent: #464646;
            --key-border: #ccc;
            
            /* Toggle Colors */
            --toggle-inactive: #ddd;
            --toggle-active: #c1bab1;
            --toggle-disabled: #f0f0f0;
            
            /* Note Colors */
            --note-black: black;
            --note-correct: rgb(62, 129, 62);
            --note-incorrect: rgb(204, 53, 53);
            --note-chord-incorrect: rgb(204, 53, 53);
            --note-support: #8e6d58;
            
            /* Staff Colors */
            --staff-line-main: #333;
            --staff-line-light: #ddd;
            --staff-border: #333;
            
            /* Border Colors */
            --border-light: #ddd;
            --border-medium: #ccc;
            --border-dark: #cfcfcf;
            --border-button: #777;
            --border-note: black;
            --border-correct-note: #4e6386;
            
            /* Progress Bar Colors */
            --progress-bg: #ddd;
            --progress-fill: #45a049;
            
            /* Control Button Colors */
            --control-btn-bg: #555;
            --control-btn-hover: #666;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: var(--bg-primary);
            user-select: none;
            
            /* Handle all safe areas */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(10px, env(safe-area-inset-left));
            padding-right: max(10px, env(safe-area-inset-right));
        }
        
        .game-container {
            max-width: 95vw;
            width: 100%;
            margin: 0 auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            padding: 0 10px;
            box-sizing: border-box;
        }

        /* Score and Settings */
        .header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 5px;
            font-size: 20px;
            position: relative;
        }

        .score-display {
            font-size: 20px;
            font-weight: bold;
        }

        .lives {
            color: var(--text-lives);
        }

        select {
            padding: 6px;
            font-size: 16px;
            border-radius: 4px;
            border: 1px solid var(--border-medium);
            color: var(--text-primary);
            min-width: 90px;
            max-width: 120px;
            width: auto;
            box-sizing: border-box;
        }

        select:disabled {
            background-color: #f5f5f5;
            color: #999;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .custom-select {
            position: relative;
            width: 120px;
            font-size: 18px;
        }

        .select-selected {
            background-color: #f9f7f3;
            padding: 2px 8px;
            border: 1px solid var(--border-medium);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-black);
        }

        .select-items {
            position: absolute;
            background-color: #f9f7f3;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 99;
            border: 1px solid var(--border-medium);
            border-top: none;
            border-radius: 0 0 4px 4px;
        }

        .select-hide {
            display: none;
        }

        .select-items div {
            color: var(--text-black);
            padding: 2px 8px;
            cursor: pointer;
        }

        .select-items div:hover {
            background-color: rgba(0,0,0,0.1);
        }

        .select-items div.selected {
            background-color: rgba(0,0,0,0.2);
        }

        .game-controls {
            background: var(--bg-game-controls);
            border-radius: 12px;
            margin-bottom: 5px;  
        }

        .toggle-label-text {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-light-gray);
            transition: color 0.3s ease;
        }

        .scale-selector {
            display: flex;
            flex-direction: column;
            gap: 0;
            border-radius: 1dvh;
            overflow: hidden;
            border: 1px solid var(--border-dark); 
            width: 100%;
        }

        .settings-row {
            display: flex;
            height: 35px;
            border-bottom: 1px solid var(--border-light);
        }

        .settings-row:last-child {
            border-bottom: none;
        }

        .toggle-item {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            border-right: 1px solid var(--border-light);
        }

        .dropdown-item {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            cursor: pointer;
        }

        .dropdown-item:hover {
            background: var(--bg-hover-light);
        }

        .dropdown-text {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .dropdown-arrow {
            font-size: 18px;
            color: var(--text-secondary);
            font-weight: bold;
        }

        .toggle-switch {
            position: relative;
        }

        .toggle-input {
            display: none;
        }

        .toggle-slider-label {
            display: block;
            width: 44px;
            height: 24px;
            background-color: var(--toggle-inactive);
            border-radius: 24px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: var(--text-white);
            transition: transform 0.3s;
        }

        .toggle-input:checked + .toggle-slider-label {
            background-color: var(--toggle-active);
        }

        .toggle-input:checked + .toggle-slider-label .toggle-slider {
            transform: translateX(20px);
        }

        .toggle-input:checked ~ .still-label,
        .toggle-input:checked ~ .scales-label,
        .toggle-input:checked ~ .chords-label {
            color: var(--text-primary) !important;
        }

        .toggle-input:disabled + .toggle-slider-label {
            background-color: var(--toggle-disabled);
            cursor: not-allowed;
        }

        .toggle-input:disabled ~ .toggle-label-text {
            color: var(--text-disabled) !important;
        }

        .end-game-btn {
            position: absolute;
            left: 0;
            padding: 4px 8px;
            font-size: 12px;
            background: var(--btn-end-game);
            color: var(--text-white);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .end-game-btn:hover {
            background: var(--btn-end-game-hover);
        }

        /* Staff Notation Area */
        .staff-area {
            background: var(--bg-white);
            border: 2px solid var(--staff-border);
            height: 280px;
            margin-bottom: 5px;
            position: relative;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }

        /* Staff Lines System - 25 evenly spaced lines */
        .staff-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            
        }

        .staff-line {
            height: 1.5px;
            background: var(--staff-line-light);
            width: 100%;
        }

        /* Above treble (lines 1-5) - light gray */
        .staff-line:nth-child(1),
        .staff-line:nth-child(2),
        .staff-line:nth-child(3),
        .staff-line:nth-child(4),
        .staff-line:nth-child(5) {
            background: var(--staff-line-light);
            opacity: 0.4;
        }

        /* Treble staff (lines 6-10) - black */
        .staff-line:nth-child(6),
        .staff-line:nth-child(7),
        .staff-line:nth-child(8),
        .staff-line:nth-child(9),
        .staff-line:nth-child(10) {
            background: var(--staff-line-main);
            opacity: 1;
        }

        /* Middle (lines 11-15) - light gray */
        .staff-line:nth-child(11),
        .staff-line:nth-child(12),
        .staff-line:nth-child(13),
        .staff-line:nth-child(14),
        .staff-line:nth-child(15) {
            background: var(--staff-line-light);
            opacity: 0.4;
        }

        /* Bass staff (lines 16-20) - black */
        .staff-line:nth-child(16),
        .staff-line:nth-child(17),
        .staff-line:nth-child(18),
        .staff-line:nth-child(19),
        .staff-line:nth-child(20) {
            background: var(--staff-line-main);
            opacity: 1;
        }

        /* Below bass (lines 21-25) - light gray */
        .staff-line:nth-child(21),
        .staff-line:nth-child(22),
        .staff-line:nth-child(23),
        .staff-line:nth-child(24),
        .staff-line:nth-child(25) {
            background: var(--staff-line-light);
            opacity: 0.4;
        }

        .treble-clef {
            position: absolute;
            object-fit: contain;
            left: 0px;
        }

        .bass-clef {
            position: absolute;
            object-fit: contain;
            left: 20px;
        }

        .moving-note {
            position: absolute;
            right: 20px;
            width: 18px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: none;
        }

        /* Oval note head with slight tilt */
        .note-head {
            width: 16px;
            height: 12px;
            background: var(--note-black);
            border-radius: 50%;
            border: 1px solid transparent;
            box-sizing: border-box;
            transform: rotate(-20deg);
            position: relative;
            z-index: 12;
        }

        .note-head.correct {
            background: var(--note-correct);
            border-color: var(--border-note);
        }

        .note-head.incorrect {
            background: var(--note-incorrect);
            border-color: var(--border-note);
        }

        /* Note stem - positioned relative to note head */
        .note-stem {
            position: absolute;
            width: 2px;
            background: var(--note-black);
            z-index: 9;
        }

        .note-stem.stem-up {
            height: 28px;
            right: 1px;
            top: -21px;
        }

        .note-stem.stem-down {
            height: 28px;
            left: 1px;
            top: 8px;
        }

        .note-stem.stem-up.middle-region {
            height: 56px;
            top: -49px;
        }

        .note-stem.stem-down.middle-region {
            height: 56px;
            top: 8px;
        }

        .moving-note.animate {
            animation: moveNote linear;
            animation-fill-mode: forwards;
        }

        @keyframes moveNote {
            from { right: -30px; }
            to { right: calc(100% + 30px); }
        }

        /* Accidentals */
        #noteAccidental {
            position: absolute;
            right: 25px;
            font-size: 18px;
            color: var(--note-black);
            z-index: 11;
            font-weight: bold;
            transform: translateY(-50%);
        }

        /* Key signature accidentals */
        .key-signature-accidental {
            position: absolute;
            color: var(--text-primary);
            z-index: 5;
            font-weight: bold;
        }

        .key.pressed {
            transform: scale(0.95);
            transition: transform 0.1s;
        }

        /* Piano Keyboard */
        .piano-container {
            margin-bottom: 15px;
        }

        .piano-keys {
            display: flex;
            justify-content: center;
            background: var(--bg-piano-container);
            padding: 8px 35px 8px 35px;
            border-radius: 8px;
            position: relative;
            width: 100%;
            box-sizing: border-box;
        }

        .key {
            margin: 0 1px;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s;
        }

        .white-key {
            width: 42px;
            height: 140px;
            background: var(--key-white);
            border: 1px solid var(--key-border);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 8px;
            font-size: 11px;
            color: transparent;
        }

        .black-key {
            width: 26px;
            height: 90px;
            background: var(--key-black);
            color: transparent;
            margin: 0 -16px;
            z-index: 4;
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 6px;
            font-size: 9px;
        }

        .black-key::before {
            content: '';
            position: absolute;
            top: 0;
            width: 16px;
            height: 90px;
            background: var(--key-black-accent);
            z-index: -1;
        }

        .black-key::after {
            content: '';
            position: absolute;
            top: 0;
            left: -6px;
            right: -6px;
            bottom: 0;
            z-index: 5;
            background: transparent;
            pointer-events: auto;
        }

        /* Left side keys - gray rectangle positioned to the left */
        .black-key:nth-child(2)::before, /* C# */
        .black-key:nth-child(5)::before  /* D# */
        {
            left: 5px;
        }

        /* Right side keys - gray rectangle positioned to the right */
        .black-key:nth-child(8)::before,  /* F# */
        .black-key:nth-child(10)::before, /* G# */
        .black-key:nth-child(14)::before  /* A# */
        {
            right: 5px;
        }

        .key:hover {
            transform: scale(0.98);
        }

        .key:active {
            transform: scale(0.95);
        }

        .key-labels-toggle {
            position: absolute;
            left: 8px;
            top: 70%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            background: var(--control-btn-bg);
            color: var(--text-white);
            border: 1px solid var(--border-button);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            user-select: none;
            z-index: 10;
            opacity: 0.5;
        }

        .key-labels-toggle:hover {
            background: var(--control-btn-hover);
        }

        .composers-area {
            display: none;
        }
                
        .sound-toggle {
            position: absolute;
            right: 8px;
            top: 20%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            background: var(--control-btn-bg);
            color: var(--text-white);
            border: 1px solid var(--border-button);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            user-select: none;
            z-index: 10;
            opacity: 0.5;
        }

        .sound-toggle:hover {
            background: var(--control-btn-hover);
        }

        .scale-display {
            font-size: 20px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .wrong-note-display {
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
        }

        .wrong-note {
            color: red;
        }

        .chord-note .note-head.incorrect {
            width: 16px;
            height: 12px;
            background: var(--note-chord-incorrect);
            border-radius: 50%;
            border: 2px solid var(--border-note);
            transform: rotate(-20deg);
            position: relative;
            z-index: 12;
        }

        .chord-note .note-head.correct {
            width: 16px;
            height: 12px;
            background: var(--note-correct);
            border-radius: 50%;
            border: 2px solid var(--border-note);
            transform: rotate(-20deg);
            position: relative;
            z-index: 12;
        }

        .correct-note-circle {
            color: var(--text-black);
            border: 2px solid var(--border-correct-note);
            border-radius: 20%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 8px;
            background: var(--progress-bg);
            border-radius: 4px;
            margin-bottom: 5px;
            overflow: hidden;
            border: 1px solid var(--border-medium);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--progress-fill) 0%, var(--progress-fill) 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }        

        .support-notes-toggle {
            position: absolute;
            left: 8px;
            top: 20%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            background: var(--control-btn-bg);
            color: var(--text-white);
            border: 1px solid var(--border-button);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            user-select: none;
            z-index: 10;
            opacity: 0.5;
        }

        .support-notes-container {
            position: absolute;
            left: 5px;
            top: 0;
            bottom: 0;
            width: 15px;
            z-index: 3;
            display: none;
        }

        .support-notes-container.active {
            display: block;
        }

        .support-note-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--note-support);
            border-radius: 50%;
            transform: translateY(-50%);
            border: 1px solid var(--border-note);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: var(--text-white);
        }

        .support-note-indicator.bass-note {
            left: -6px;
        }

        .support-note-indicator.treble-note {
            left: 3px;
        }

        /* Start Game Overlay */
        .game-start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-overlay-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-white);
            font-size: 20px;
            flex-direction: column;
            z-index: 15;
        }

        .start-game-btn {
            margin-top: 15px;
            padding: 12px 24px;
            font-size: 20px;
            background: var(--btn-start-game);
            color: whitesmoke;
            border: 1px solid var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
        }

        .start-game-btn:hover {
            background: var(--btn-start-game-hover);
        }

        /* Game Over */
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-overlay-dark);
            display: none;
            align-items: center;
            justify-content: center;
            color: var(--text-white);
            font-size: 24px;
            flex-direction: column;
            z-index: 100;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .play-again-btn {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 10px 20px;
            font-size: 20px;
            background: var(--btn-play-again);
            color: var(--text-white);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Visual Feedback */
        .screen-flicker {
            animation: flicker 0.5s ease-in-out;
        }

        @keyframes flicker {
            0%, 100% { filter: brightness(1); }
            25% { filter: brightness(0.7); }
            50% { filter: brightness(1.2); }
            75% { filter: brightness(0.9); }
        }

        .difficulty-display {
            position: absolute;
            right: 0;
            font-size: 15px;
            color: var(--text-secondary);
        }

        /* Mode selector */
        .mode-selector {
            margin-bottom: 10px;
        }

        /* Game container layout adjustment */
        .game-container {
            max-width: 400px;
            margin: 0 auto;
            text-align: center;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            order: 1;
        }

        /* Still mode styles */
        .still-note {
            position: absolute;
            width: 18px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .still-notes-container {
            position: absolute;
            top: 0;
            left: 80px;
            right: 20px;
            height: 100%;
            display: none;
        }

        .still-notes-container.active {
            display: block;
        }


        /* Landscape Mode Styles */
        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-size: 12px;
            z-index: 1000;
            border-radius: 5px;
            display: none;
        }
        
        /* Enhanced landscape mode detection */
        /* Enhanced landscape mode detection */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            body.landscape-mode-active {
                --total-white-keys: 14;
                --internal-padding: 20px;
                --container-insets: 40px;
                --key-spacing: 2px;
                
                --available-width: calc(100vw - (var(--container-insets) * 2) - (var(--internal-padding) * 2));
                --total-spacing: calc(var(--key-spacing) * (var(--total-white-keys) - 1));
                --white-key-width: calc((var(--available-width) - var(--total-spacing)) / var(--total-white-keys));
                --black-key-width: calc(var(--white-key-width) * 0.6);
                --black-key-offset: calc(var(--white-key-width) * -0.3);
                
                --staff-area-width: 400px !important;
                --available-side-space: calc(100vw - var(--staff-area-width) - max(env(safe-area-inset-left), 20px) - max(env(safe-area-inset-right), 20px)) !important;
                --left-panel-width: calc(var(--available-side-space) * 0.5) !important;
                --right-panel-width: calc(var(--available-side-space) * 0.5) !important;
            }

            /* Landscape mode left and right panels */
            body.landscape-mode-active .left-panel {
                position: fixed;
                left: max(env(safe-area-inset-left), 20px);
                top: 20px;
                width: min(180px, calc(var(--left-panel-width) - 40px));
                z-index: 30;
                background: var(--bg-game-controls);
                border-radius: 12px;
                padding: 15px;
                box-sizing: border-box;
                max-height: calc(100vh - 200px);
                overflow-y: auto;
            }

            body.landscape-mode-active .right-panel {
                position: fixed;
                right: max(env(safe-area-inset-right), 20px);
                top: 20px;
                width: min(180px, calc(var(--right-panel-width) - 40px));
                z-index: 30;
                background: var(--bg-game-controls);
                border-radius: 12px;
                padding: 15px;
                box-sizing: border-box;
                max-height: calc(100vh - 200px);
                overflow-y: auto;
            }

            /* Single column layout for toggles */
            body.landscape-mode-active .left-panel .toggle-column {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            body.landscape-mode-active .left-panel .toggle-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 6px 0;
                border-bottom: 1px solid var(--border-light);
            }

            body.landscape-mode-active .left-panel .toggle-row:last-child {
                border-bottom: none;
            }

            body.landscape-mode-active .left-panel .toggle-label-text {
                font-size: 14px;
                flex: 1;
            }

            /* Single column layout for dropdowns */
            body.landscape-mode-active .right-panel .dropdown-column {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            body.landscape-mode-active .right-panel .dropdown-row {
                padding: 8px;
                background: rgba(255,255,255,0.5);
                border-radius: 6px;
                cursor: pointer;
                transition: background 0.2s;
            }

            body.landscape-mode-active .right-panel .dropdown-row:hover {
                background: rgba(255,255,255,0.7);
            }

            body.landscape-mode-active .right-panel .dropdown-text {
                font-size: 14px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            /* Hide the original game controls in landscape */
            body.landscape-mode-active .game-controls {
                display: none !important;
            }

            /* Center the game content */
            body.landscape-mode-active .game-container {
                width: 400px;
                max-width: var(--staff-area-width);
                margin: 0 auto;
                text-align: center;
                display: flex;
                flex-direction: column;
                padding: 0 10px;
                box-sizing: border-box;
            }

            body.landscape-mode-active .main-content {
                margin: 0 auto;
                max-width: var(--staff-area-width);
                order: 1;
                width: 400px;
            }

            body.landscape-mode-active .header {
                position: relative !important;
                top: auto !important;
                left: auto !important;
                right: auto !important;
                flex-direction: row !important;
                justify-content: center !important;
                align-items: center !important;
                margin-bottom: 10px !important;
                z-index: 10 !important;
                width: 100% !important;
                box-sizing: border-box !important;
                padding: 0 20px !important;
            }

            body.landscape-mode-active .game-start-overlay {
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: var(--bg-overlay-dark) !important;
                align-items: center !important;
                justify-content: center !important;
                color: var(--text-white) !important;
                font-size: 20px !important;
                flex-direction: column !important;
                z-index: 15 !important;
            }
            
            body.landscape-mode-active .start-game-btn {
                position: absolute !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                margin-top: 0 !important;
                padding: 10px 20px !important;
                font-size: 18px !important;
                background: var(--btn-start-game) !important;
                color: whitesmoke !important;
                border: 1px solid var(--text-primary) !important;
                border-radius: 6px !important;
                cursor: pointer !important;
                z-index: 16 !important;
            }

            body.landscape-mode-active .clef-toggle-button {
                right: 10px !important;
                top: 70px !important;
                z-index: 100 !important;
            }

            body.landscape-mode-active .end-game-btn {
                position: absolute !important;
                left: 0px !important;
            }
            
            body.landscape-mode-active .difficulty-display {
                position: absolute !important;
                right: 0px !important;
            }

            /* FIXED: Ensure the staff area maintains proper height */
            body.landscape-mode-active .staff-area {
                height: 140px !important;
                min-height: 140px !important;
                width: 100% !important;
                position: relative !important;
                border: 2px solid #333 !important;
                background: white !important;
                margin-top: 0px !important;
                margin-bottom: 5px !important;
                overflow: hidden !important;
                display: block !important;
            }

            body.landscape-mode-active .staff-inner {
                position: absolute !important;
                width: 100% !important;
                height: 280px !important;
                top: 0 !important;
                left: 0 !important;
                transition: top 0.3s ease !important;
            }

            body.landscape-mode-active.treble-view .staff-inner {
                top: 0px !important;
            }

            body.landscape-mode-active.bass-view .staff-inner {
                top: -140px !important;
            }

            body.landscape-mode-active .staff-inner .moving-note,
            body.landscape-mode-active .staff-inner .still-note,
            body.landscape-mode-active .staff-inner .support-note-indicator {
                position: absolute !important;
            }

            body.landscape-mode-active .staff-lines {
                height: 280px !important;
                position: relative !important;
            }

            body.landscape-mode-active .staff-lines,
            body.landscape-mode-active .moving-note,
            body.landscape-mode-active .still-note,
            body.landscape-mode-active .treble-clef,
            body.landscape-mode-active .bass-clef,
            body.landscape-mode-active .support-notes-container,
            body.landscape-mode-active .still-notes-container,
            body.landscape-mode-active .key-signature-accidental {
                position: absolute !important;
            }

            /* Progress bar positioning */
            body.landscape-mode-active .progress-container {
                width: 100%;
                height: 8px;
                background: var(--progress-bg);
                border-radius: 4px;
                margin-bottom: 5px;
                overflow: hidden;
                border: 1px solid var(--border-medium);
            }

            /* Composers area positioning */
            body.landscape-mode-active .composers-area {
                margin-bottom: 10px;
            }

            /* Piano positioning */
            body.landscape-mode-active .piano-container {
                position: fixed !important;
                bottom: 0 !important;
                left: max(env(safe-area-inset-left), 20px) !important;
                right: max(env(safe-area-inset-right), 20px) !important;
                width: auto !important;
                z-index: 20 !important;
                background: #333 !important;
                padding: 8px 0 !important;
                border-radius: 8px !important;
                margin-bottom: 0 !important;
            }
            
            body.landscape-mode-active .piano-keys {
                width: 100% !important;
                padding: 0 60px !important;
                margin: 0 !important;
                display: flex !important;
                justify-content: center !important;
                box-sizing: border-box !important;
                background: #333 !important;
                border-radius: 8px !important;
            }
            
            body.landscape-mode-active .white-key {
                flex: 1 1 auto !important;
                min-width: 30px !important;
                max-width: 50px !important;
                height: 140px !important;
                margin: 0 1px !important;
                border: 1px solid #ccc !important;
                background: white !important;
                display: flex !important;
                align-items: flex-end !important;
                justify-content: center !important;
                padding-bottom: 8px !important;
                cursor: pointer !important;
                transition: transform 0.1s !important;
                font-size: clamp(9px, 2vw, 12px) !important;
            }
            
            body.landscape-mode-active .black-key {
                flex: 0 0 auto !important;
                width: calc(100% / 14 * 0.6) !important;
                height: 90px !important;
                background: #333 !important;
                color: transparent !important;
                margin: 0 calc(-100% / 14 * 0.3) !important;
                z-index: 24 !important;
                position: relative !important;
                cursor: pointer !important;
                display: flex !important;
                align-items: flex-end !important;
                justify-content: center !important;
                padding-bottom: 6px !important;
                font-size: clamp(7px, 1.5vw, 10px) !important;
                transition: transform 0.1s !important;
            }
            
            body.landscape-mode-active .black-key::before {
                content: '';
                position: absolute;
                top: 0;
                width: 80%;
                height: 90px;
                background: #464646;
                z-index: -1;
                left: 50%;
                transform: translateX(-50%);
            }
            
            body.landscape-mode-active .key-labels-toggle,
            body.landscape-mode-active .support-notes-toggle,
            body.landscape-mode-active .sound-toggle {
                position: absolute !important;
                z-index: 25 !important;
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
                background: #555 !important;
                color: white !important;
                border: 1px solid #777 !important;
                border-radius: 50% !important;
                cursor: pointer !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                opacity: 0.8 !important;
                transition: opacity 0.3s !important;
            }

            body.landscape-mode-active .key-labels-toggle {
                left: 10px !important;
                top: 30px !important;
            }

            body.landscape-mode-active .support-notes-toggle {
                left: 10px !important;
                top: 65px !important;
            }

            body.landscape-mode-active .sound-toggle {
                right: 10px !important;
                top: 30px !important;
            }

            body.landscape-mode-active .key:hover {
                transform: scale(0.98) !important;
            }
            
            body.landscape-mode-active .key:active,
            body.landscape-mode-active .key.pressed {
                transform: scale(0.95) !important;
            }

            body.landscape-mode-active .clef-toggle-button {
                display: flex !important;
                position: absolute !important;
                right: 50px !important;
                top: 60px !important;
                width: 50px !important;
                height: 50px !important;
                font-size: 30px !important;
                z-index: 100 !important;
            }
        }

        /* Portrait mode - hide octave indicators */
        .octave-indicator {
            display: none;
        }

        /* Clef Toggle Button Styles */
        .clef-toggle-button {
            display: none;
            position: absolute;
            right: 10px;
            top: 70px;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.9);
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            z-index: 100;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .clef-toggle-button:disabled,
        .clef-toggle-button.disabled {
            opacity: 0.5 !important;
            pointer-events: none !important;
            cursor: not-allowed !important;
        }
    </style>
</head>

<body>

    <div class="debug-info" id="debugInfo">
        <div>Orientation: <span id="orientationInfo">-</span></div>
        <div>Viewport: <span id="viewportInfo">-</span></div>
        <div>Chord Mode: <span id="chordModeInfo">-</span></div>
        <div>Two Octave: <span id="twoOctaveInfo">-</span></div>
    </div>
    
    <div class="game-container">
        <!-- Header with Score and Settings -->
        <div class="header">
            <div class="score-display">
                Hit: <span id="score">0</span>/<span id="targetScore">80</span> |
                <span class="lives">Miss: <span id="lives">0</span>/3</span>
            </div>
            <button id="endGameBtn" class="end-game-btn" onclick="endGame()" style="display: none;">End Game</button>
            <div class="difficulty-display" id="difficulty">Beginner</div>
        </div>

        <div class="main-content">
            <!-- Game Controls Container -->
            <div class="game-controls">
                
                <!-- Scale Selection -->
                <div class="scale-selector">
                    <div class="settings-row">
                        <div class="toggle-item">
                            <span class="toggle-label-text notes-label">Notes</span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="notesToggle" class="toggle-input" checked>
                                <label for="notesToggle" class="toggle-slider-label">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="toggle-item">
                            <span class="toggle-label-text move-label">Move</span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="gameModeToggle" class="toggle-input" checked>
                                <label for="gameModeToggle" class="toggle-slider-label">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="dropdown-item" id="levelDropdown">
                            <span class="dropdown-text">Beginner</span>
                            <span class="dropdown-arrow">›</span>
                        </div>
                    </div>
                    
                    <div class="settings-row">
                        <div class="toggle-item">
                            <span class="toggle-label-text scales-label">Scales</span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="scalesToggle" class="toggle-input">
                                <label for="scalesToggle" class="toggle-slider-label">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="toggle-item">
                            <span class="toggle-label-text still-label">Still</span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="stillToggle" class="toggle-input">
                                <label for="stillToggle" class="toggle-slider-label">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="dropdown-item" id="regionDropdown">
                            <span class="dropdown-text">All Regions</span>
                            <span class="dropdown-arrow">›</span>
                        </div>
                    </div>
                    
                    <div class="settings-row">
                        <div class="toggle-item">
                            <span class="toggle-label-text chords-label">Chords</span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="chordsToggle" class="toggle-input">
                                <label for="chordsToggle" class="toggle-slider-label">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="toggle-item">
                            <!-- Empty third row for column 2 -->
                        </div>
                        <div class="dropdown-item" id="keyDropdown">
                            <span class="dropdown-text">C Major</span>
                            <span class="dropdown-arrow">›</span>
                        </div>
                    </div>
                    
                    <!-- Hidden selects for functionality -->
                    <select id="difficultySelect" style="display: none;">
                        <option value="beginner">Beginner</option>
                        <option value="novice">Novice</option>
                        <option value="intermediate">Intermediate</option>
                        <option value="advanced">Advanced</option>
                        <option value="expert">Expert</option>
                        <option value="master">Master</option>
                        <option value="legendary">Legendary</option>
                        <option value="impossible">Impossible</option>
                    </select>
                    
                    <select id="regionSelect" style="display: none;">
                        <option value="all">All Regions</option>
                        <option value="above">Above Treble</option>
                        <option value="treble">Treble Clef</option>
                        <option value="middle">Middle</option>
                        <option value="bass">Bass Clef</option>
                        <option value="below">Below Bass</option>
                        <option value="above,below">Above + Below</option>
                        <option value="treble,bass">Treble + Bass</option>
                    </select>
                    
                    <select id="scale" style="display: none;">
                        <option value="C">C Major</option>
                        <option value="D">D Major</option>
                        <option value="E">E Major</option>
                        <option value="F">F Major</option>
                        <option value="G">G Major</option>
                        <option value="A">A Major</option>
                        <option value="B">B Major</option>
                        <option value="Cm">C Minor</option>
                        <option value="Dm">D Minor</option>
                        <option value="Em">E Minor</option>
                        <option value="Fm">F Minor</option>
                        <option value="Gm">G Minor</option>
                        <option value="Am">A Minor</option>
                        <option value="Bm">B Minor</option>
                        <option value="random">Random</option>
                    </select>
                </div>
            </div>


            <!-- Staff Notation Area -->
            <div class="staff-area">

                <div class="support-notes-container" id="supportNotesContainer">
                <!-- Support note indicators will be generated here -->
                </div>

            <!-- Start Game Overlay -->
            <div class="game-start-overlay" id="gameStartOverlay">
                <button class="start-game-btn" onclick="startNewGame()">Start Game</button>
            </div>

            <!-- Staff Lines System -->
            <div class="staff-lines">
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
                <div class="staff-line"></div>
            </div>

            <!-- Clef Symbols -->
            <img class="treble-clef" src="images/G.png" alt="Treble Clef">
            <img class="bass-clef" src="images/F.png" alt="Bass Clef">

            <!--div class="clef-symbol treble-clef">𝄞</div-->
            <!--div class="clef-symbol bass-clef">𝄢</div-->
            
            <!-- Still Notes Container -->
            <div class="still-notes-container" id="stillNotesContainer">
                <!-- Still notes will be generated here -->
            </div>
        </div>

        <!-- Progress Bar -->
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <!-- Composers Collection Area -->
        <div class="composers-area">
            <div id="scaleDisplay" class="scale-display" style="display: none;">Scale: C Major</div>
            <div id="wrongNoteDisplay" class="wrong-note-display" style="display: none;">
                <span class="wrong-note" id="wrongNote"></span>
                <span class="correct-note-circle" id="correctNote"></span>
            </div>
        </div>

        <!-- Piano Keyboard -->
        <div class="piano-container">
            <div class="piano-keys" id="pianoKeys">
                <!-- Keys will be generated by JavaScript -->
            </div>
        </div>

        <div id="scaleInfoContainer" style="display: none; width: 100%; margin-top: 2px;">
            <div id="currentScaleDisplay" style="font-size: 16px; color: #666; margin-bottom: 4px; text-align: center;">
                Scale: C Major
            </div>
            <div id="miniStaffDisplay" style="position: relative; height: 80px; width: 300px; margin: 0 auto;">
                <!-- Mini staff container with positioning variables -->
                <div id="miniTrebleStaff" style="position: absolute; top: 10px; left: 40px;">
                    <!-- Treble staff lines -->
                    <div style="position: absolute; top: 0px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 10px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 20px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 30px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 40px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    
                    <!-- Treble clef -->
                    <img src="images/G.png" alt="Treble Clef" style="position: absolute; left: 5px; top: -8px; width: 23px; height: 60px;filter: invert(1) grayscale(1) brightness(0.4);">
                </div>
                
                <div id="miniBassStaff" style="position: absolute; top: 10px; left: 160px;filter: invert(1) grayscale(1) brightness(0.4);">
                    <!-- Bass staff lines -->
                    <div style="position: absolute; top: 0px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 10px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 20px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 30px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    <div style="position: absolute; top: 40px; left: 0; width: 100px; height: 1px; background: #666;"></div>
                    
                    <!-- Bass clef -->
                    <img src="images/F.png" alt="Bass Clef" style="position: absolute; left: 0px; top: 0px; width: 40px; height: 30px;">
                </div>
                
                <!-- Accidentals container -->
                <div id="miniAccidentalsContainer"></div>
            </div>
        </div>



        <!-- Game Over Screen -->
        <div class="game-over" id="gameOver">
            <div>Game Over!</div>
            <div>Final Score: <span id="finalScore">0</span></div>
            <button class="play-again-btn" onclick="showStartScreen()">Back to game</button>
        </div>
    </div>

    <script>

        // Game Configuration
        const TARGET_SCORE = 80;

        // Global sound state
        window.soundEnabled = true;

        // Game State
        let gameState = {
            score: 0,
            consecutiveMisses: 0,
            currentNote: null,
            currentNoteOctave: 4,
            selectedScale: 'C',
            difficulty: 'beginner',
            gameMode: 'moving',
            noteMode: 'random',
            currentScale: {
                notes: [],
                currentIndex: 0,
                clef: null,
                scaleName: null
            },
            isPlaying: false,
            waitingForAnswer: false,
            noteStartTime: 0,
            activeNotes: [],
            stillNotes: [],
            currentStillNoteIndex: 0,
            selectedRegions: ['above', 'treble', 'middle', 'bass', 'below']  
        };

        // Complete note position mapping
        const NOTE_POSITIONS = {
            // Top ledger lines (above treble staff) - positions 1-9
            'A6': 2,    'G6': 3,    'F6': 4,    'E6': 5,    'D6': 6,    'C6': 7,    'B5': 8,    'A5': 9,    'G5': 10,
            
            // Treble staff (G clef) - positions 10-18
            'F5': 11,   'E5': 12,   'D5': 13,   'C5': 14,   'B4': 15,   'A4': 16,   'G4': 17,   'F4': 18,   'E4': 19,
           
            // Middle section - treble only, positions 20-25
            'D4_treble': 20,     'C4_treble': 21,     'B3_treble': 22,
            'A3_treble': 23,     'G3_treble': 24,     'F3_treble': 25, 

            // Middle section - bass only, positions 25-30
            'G4_bass': 25,       'F4_bass': 26,       'E4_bass': 27,       
            'D4_bass': 28,       'C4_bass': 29,       'B3_bass': 30,

            // Bass staff (F clef) - positions 30-38
            'A3': 31,   'G3': 32,   'F3': 33,   'E3': 34,   'D3': 35,   'C3': 36,   'B2': 37,   'A2': 38,   'G2': 39,

            // Below bass staff - positions 39-47
            'F2': 40,   'E2': 41,   'D2': 42,   'C2': 43,   'B1': 44,   'A1': 45,   'G1': 46,   'F1': 47,   'E1': 48
        };

        // Create complete note dictionary
        const ALL_POSSIBLE_NOTES = {};

        // Populate it from existing NOTE_POSITIONS
        Object.keys(NOTE_POSITIONS).forEach(key => {
            const match = key.match(/([A-G][#b]?)(\d+)(_treble|_bass)?/);
            if (match) {
                const note = match[1];
                const octave = parseInt(match[2]);
                const hand = match[3] || '';
                const position = NOTE_POSITIONS[key];
                
                ALL_POSSIBLE_NOTES[key] = {
                    note: note,
                    octave: octave,
                    hand: hand,
                    position: position,
                    region: getRegionFromPosition(position)
                };
            }
        });

        function getRegionFromPosition(position) {
            if (position <= 10) return 'above';
            if (position >= 11 && position <= 19) return 'treble';
            if (position >= 20 && position <= 30) return 'middle';
            if (position >= 31 && position <= 39) return 'bass';
            return 'below';
        }

        function buildChordFromRoot(chordNotes, rootKey, clef) {
            const rootData = ALL_POSSIBLE_NOTES[rootKey];
            const chordPositions = [];
            let currentOctave = rootData.octave;
            
            for (let i = 0; i < chordNotes.length; i++) {
                const targetNote = chordNotes[i];
                const noteLetter = targetNote.replace('#', '').replace('b', '');
                
                // Handle octave increment for chord progression
                if (i > 0) {
                    const prevNote = chordNotes[i-1].replace('#', '').replace('b', '');
                    const noteOrder = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                    const prevIndex = noteOrder.indexOf(prevNote);
                    const currentIndex = noteOrder.indexOf(noteLetter);
                    
                    if (currentIndex <= prevIndex) {
                        currentOctave++;
                    }
                }
                
                // Find the note in this octave
                const possibleKeys = [
                    noteLetter + currentOctave,
                    noteLetter + currentOctave + '_treble',
                    noteLetter + currentOctave + '_bass'
                ].filter(key => ALL_POSSIBLE_NOTES[key]);
                
                // Pick the best key for this clef with proper middle region limits
                let bestKey = null;
                for (let key of possibleKeys) {
                    const noteData = ALL_POSSIBLE_NOTES[key];
                    if (clef === 'treble') {
                        // Treble: can go from position 2 to 25 (down to F3 in middle)
                        if (noteData.position >= 2 && noteData.position <= 25) {
                            bestKey = key;
                            break;
                        }
                    } else if (clef === 'bass') {
                        // Bass: can go from position 25 to 48 (up to G4 in middle) 
                        if (noteData.position >= 25 && noteData.position <= 48) {
                            bestKey = key;
                            break;
                        }
                    }
                }
                
                if (!bestKey) return null; // Chord doesn't fit
                
                chordPositions.push({
                    note: targetNote,
                    octave: currentOctave,
                    hand: ALL_POSSIBLE_NOTES[bestKey].hand,
                    fullKey: bestKey,
                    position: ALL_POSSIBLE_NOTES[bestKey].position
                });
            }
            
            return {
                clef: clef,
                notes: chordPositions
            };
        }

        // Get vertical position for note on staff
        function getNotePosition(note, octave, hand = '') {
            let noteKey = note + octave + hand;
            if (NOTE_POSITIONS[noteKey]) {
                const positionNumber = NOTE_POSITIONS[noteKey];
                // FIXED: Always calculate based on full 280px height
                const isLandscapeChordMode = document.body.classList.contains('landscape-mode-active');
                if (isLandscapeChordMode) {
                    // In landscape mode, calculate position relative to full height
                    // but within the inner container
                    return `${(positionNumber - 1) * (280 / 48) + 7}px`;
                } else {
                    // Normal percentage-based positioning
                    return `calc(${positionNumber - 1} * (100% / 48))`;
                }
            }
            
            noteKey = note + octave;
            if (NOTE_POSITIONS[noteKey]) {
                const positionNumber = NOTE_POSITIONS[noteKey];
                const isLandscapeChordMode = document.body.classList.contains('landscape-mode-active');
                if (isLandscapeChordMode) {
                    return `${(positionNumber - 1) * (280 / 48) + 7}px`;
                } else {
                    return `calc(${positionNumber - 1} * (100% / 48))`;
                }
            }
            
            // Default position
            const isLandscapeChordMode = document.body.classList.contains('landscape-mode-active');
            if (isLandscapeChordMode) {
                return `${14 * (280 / 48)}px`;
            } else {
                return 'calc(14 * (100% / 48))';
            }
        }

        function playPianoKey(pressedNote) {
            if (gameState.gameMode === 'moving') {
                handleMovingNoteGuess(pressedNote);
            } else {
                handleStillNoteGuess(pressedNote);
            }
        }

        // Scale definitions
        const SCALES = {
            'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#'],
            'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'],
            'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'],
            'E': ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#'],
            'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E'],
            'B': ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#'],
            'Am': ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
            'Em': ['E', 'F#', 'G', 'A', 'B', 'C', 'D'],
            'Bm': ['B', 'C#', 'D', 'E', 'F#', 'G', 'A'],
            'Dm': ['D', 'E', 'F', 'G', 'A', 'Bb', 'C'],
            'Gm': ['G', 'A', 'Bb', 'C', 'D', 'Eb', 'F'],
            'Cm': ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb'],
            'Fm': ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'Eb']
        };

        const CHORDS = {
            // Major Triads
            'C': ['C', 'E', 'G'],
            'C#': ['C#', 'F', 'G#'],
            'D': ['D', 'F#', 'A'],
            'D#': ['D#', 'G', 'A#'],
            'E': ['E', 'G#', 'B'],
            'F': ['F', 'A', 'C'],
            'F#': ['F#', 'A#', 'C#'],
            'G': ['G', 'B', 'D'],
            'G#': ['G#', 'C', 'D#'],
            'A': ['A', 'C#', 'E'],
            'A#': ['A#', 'D', 'F'],
            'B': ['B', 'D#', 'F#'],
            // Minor Triads
            'Cm': ['C', 'D#', 'G'],
            'C#m': ['C#', 'E', 'G#'],
            'Dm': ['D', 'F', 'A'],
            'D#m': ['D#', 'F#', 'A#'],
            'Em': ['E', 'G', 'B'],
            'Fm': ['F', 'G#', 'C'],
            'F#m': ['F#', 'A', 'C#'],
            'Gm': ['G', 'A#', 'D'],
            'G#m': ['G#', 'B', 'D#'],
            'Am': ['A', 'C', 'E'],
            'A#m': ['A#', 'C#', 'F'],
            'Bm': ['B', 'D', 'F#'],
            // Diminished
            'Cdim': ['C', 'D#', 'F#'],
            'C#dim': ['C#', 'E', 'G'],
            'Ddim': ['D', 'F', 'G#'],
            'D#dim': ['D#', 'F#', 'A'],
            'Edim': ['E', 'G', 'A#'],
            'Fdim': ['F', 'G#', 'B'],
            'F#dim': ['F#', 'A', 'C'],
            'Gdim': ['G', 'A#', 'C#'],
            'G#dim': ['G#', 'B', 'D'],
            'Adim': ['A', 'C', 'D#'],
            'A#dim': ['A#', 'C#', 'E'],
            'Bdim': ['B', 'D', 'F'],
            // Augmented
            'Caug': ['C', 'E', 'G#'],
            'C#aug': ['C#', 'F', 'A'],
            'Daug': ['D', 'F#', 'A#'],
            'D#aug': ['D#', 'G', 'B'],
            'Eaug': ['E', 'G#', 'C'],
            'Faug': ['F', 'A', 'C#'],
            'F#aug': ['F#', 'A#', 'D'],
            'Gaug': ['G', 'B', 'D#'],
            'G#aug': ['G#', 'C', 'E'],
            'Aaug': ['A', 'C#', 'F'],
            'A#aug': ['A#', 'D', 'F#'],
            'Baug': ['B', 'D#', 'G'],
            // Dominant 7th
            'C7': ['C', 'E', 'G', 'A#'],
            'C#7': ['C#', 'F', 'G#', 'B'],
            'D7': ['D', 'F#', 'A', 'C'],
            'D#7': ['D#', 'G', 'A#', 'C#'],
            'E7': ['E', 'G#', 'B', 'D'],
            'F7': ['F', 'A', 'C', 'D#'],
            'F#7': ['F#', 'A#', 'C#', 'E'],
            'G7': ['G', 'B', 'D', 'F'],
            'G#7': ['G#', 'C', 'D#', 'F#'],
            'A7': ['A', 'C#', 'E', 'G'],
            'A#7': ['A#', 'D', 'F', 'G#'],
            'B7': ['B', 'D#', 'F#', 'A'],
            // Minor 7th
            'Cm7': ['C', 'D#', 'G', 'A#'],
            'C#m7': ['C#', 'E', 'G#', 'B'],
            'Dm7': ['D', 'F', 'A', 'C'],
            'D#m7': ['D#', 'F#', 'A#', 'C#'],
            'Em7': ['E', 'G', 'B', 'D'],
            'Fm7': ['F', 'G#', 'C', 'D#'],
            'F#m7': ['F#', 'A', 'C#', 'E'],
            'Gm7': ['G', 'A#', 'D', 'F'],
            'G#m7': ['G#', 'B', 'D#', 'F#'],
            'Am7': ['A', 'C', 'E', 'G'],
            'A#m7': ['A#', 'C#', 'F', 'G#'],
            'Bm7': ['B', 'D', 'F#', 'A'],
            // Suspended
            'Csus2': ['C', 'D', 'G'],
            'Csus4': ['C', 'F', 'G'],
            'Dsus2': ['D', 'E', 'A'],
            'Dsus4': ['D', 'G', 'A'],
            'Esus2': ['E', 'F#', 'B'],
            'Esus4': ['E', 'A', 'B'],
            'Fsus2': ['F', 'G', 'C'],
            'Fsus4': ['F', 'A#', 'C'],
            // Add9
            'Cadd9': ['C', 'E', 'G', 'D'],
            'Dadd9': ['D', 'F#', 'A', 'E'],
            'Eadd9': ['E', 'G#', 'B', 'F#'],
            'Fadd9': ['F', 'A', 'C', 'G'],
            'Gadd9': ['G', 'B', 'D', 'A'],
            'Aadd9': ['A', 'C#', 'E', 'B'],
            'Badd9': ['B', 'D#', 'F#', 'C#'],
            // 6th
            'C6': ['C', 'E', 'G', 'A'],
            'Cm6': ['C', 'D#', 'G', 'A'],
            'D6': ['D', 'F#', 'A', 'B'],
            'Dm6': ['D', 'F', 'A', 'B'],
            'E6': ['E', 'G#', 'B', 'C#'],
            'Em6': ['E', 'G', 'B', 'C#'],
            'F6': ['F', 'A', 'C', 'D'],
            'Fm6': ['F', 'G#', 'C', 'D']
            // Add more as needed
        };

        function findValidChordPositions(chordNotes) {
            return findValidChordPositionsSimple(chordNotes);
        }

        function findValidChordPositionsSimple(chordNotes) {
            const validPositions = [];
            
            // For each clef, try to build complete chords
            ['treble', 'bass'].forEach(clef => {
                // Get all possible starting notes for this chord's root
                const rootNote = chordNotes[0].replace('#', '').replace('b', '');
                
                const possibleRoots = Object.keys(ALL_POSSIBLE_NOTES).filter(key => {
                    const noteData = ALL_POSSIBLE_NOTES[key];
                    const noteLetter = noteData.note.replace('#', '').replace('b', '');
                    
                    // Check if clef appropriate and region makes sense
                    if (clef === 'treble') {
                        return noteLetter === rootNote && noteData.position >= 2 && noteData.position <= 25;
                    } else {
                        return noteLetter === rootNote && noteData.position >= 25 && noteData.position <= 48;
                    }
                });
                
                // For each possible root, try to build the complete chord
                possibleRoots.forEach(rootKey => {
                    const chordPosition = buildChordFromRoot(chordNotes, rootKey, clef);
                    if (chordPosition) {
                        validPositions.push(chordPosition);
                    }
                });
            });
            
            return validPositions;
        }

        function generateChord() {
            const chordKeys = Object.keys(CHORDS);
            const randomChord = chordKeys[Math.floor(Math.random() * chordKeys.length)];
            const chordNotes = CHORDS[randomChord];
            
            const validPositions = findValidChordPositions(chordNotes);
            if (validPositions.length === 0) {
                
                return generateNote(); // Fallback to single note
            }
            
            const selectedPosition = validPositions[Math.floor(Math.random() * validPositions.length)];
            
            return {
                chordName: randomChord,
                notes: selectedPosition.notes,
                clef: selectedPosition.clef,
                isChord: true,
                area: selectedPosition.clef
            };
        }


        // Scale definitions and accidental positions
        const SCALE_DEFINITIONS = {
            'C': [], 'G': ['F#'], 'D': ['F#', 'C#'], 'A': ['F#', 'C#', 'G#'], 'E': ['F#', 'C#', 'G#', 'D#'],
            'F': ['Bb'], 'B': ['C#', 'D#', 'F#','G#', 'A#'], 'Am': [], 'Em': ['F#'], 'Bm': ['F#', 'C#'],
            'Dm': ['Bb'], 'Gm': ['Bb', 'Eb'], 'Cm': ['Bb', 'Eb', 'Ab'], 'Fm': ['Bb', 'Eb', 'Ab','Db']
        };

        const ACCIDENTAL_POSITIONS = {
            // Sharp positions (in order: F# C# G# D# A# E# B#)
            'F#': [
                { clef: 'treble', position: 18 }, // F space in treble (F4 position)
                { clef: 'bass', position: 33 }    // F line in bass (F2 position)
            ],
            'C#': [
                { clef: 'treble', position: 14 }, // C space in treble (C5 position)
                { clef: 'bass', position: 36 }    // C space in bass (C2 position)
            ],
            'G#': [
                { clef: 'treble', position: 17 }, // G line in treble (G4 position)
                { clef: 'bass', position: 32 }    // G space in bass (G2 position)
            ],
            'D#': [
                { clef: 'treble', position: 13 }, // D line in treble (D5 position)
                { clef: 'bass', position: 35 }    // D line in bass (D2 position)
            ],
            'A#': [
                { clef: 'treble', position: 16 }, // A space in treble (A4 position)
                { clef: 'bass', position: 31 }    // A line in bass (A2 position)
            ],
            'E#': [
                { clef: 'treble', position: 12 }, // E space in treble (E5 position)
                { clef: 'bass', position: 34 }    // E space in bass (E2 position)
            ],
            'B#': [
                { clef: 'treble', position: 15 }, // B line in treble (B4 position)
                { clef: 'bass', position: 37 }    // B line in bass (B1 position)
            ],
            
            // Flat positions (in order: Bb Eb Ab Db Gb Cb Fb)
            'Bb': [
                { clef: 'treble', position: 15 }, // B line in treble (B4 position)
                { clef: 'bass', position: 37 }    // B line in bass (B1 position)
            ],
            'Eb': [
                { clef: 'treble', position: 12 }, // E space in treble (E5 position)
                { clef: 'bass', position: 34 }    // E space in bass (E2 position)
            ],
            'Ab': [
                { clef: 'treble', position: 16 }, // A space in treble (A4 position)
                { clef: 'bass', position: 31 }    // A line in bass (A2 position)
            ],
            'Db': [
                { clef: 'treble', position: 13 }, // D line in treble (D5 position)
                { clef: 'bass', position: 35 }    // D line in bass (D2 position)
            ],
            'Gb': [
                { clef: 'treble', position: 17 }, // G line in treble (G4 position)
                { clef: 'bass', position: 32 }    // G space in bass (G2 position)
            ],
            'Cb': [
                { clef: 'treble', position: 14 }, // C space in treble (C5 position)
                { clef: 'bass', position: 36 }    // C space in bass (C2 position)
            ],
            'Fb': [
                { clef: 'treble', position: 18 }, // F space in treble (F4 position)
                { clef: 'bass', position: 33 }    // F line in bass (F2 position)
            ]
        };

        // Composers list
        const COMPOSERS = [
            'Bach', 'Mozart', 'Beethoven', 'Chopin', 'Liszt', 
            'Debussy', 'Rachmaninoff', 'Brahms', 'Schubert', 'Tchaikovsky'
        ];

        // Difficulty settings
        const DIFFICULTY_SETTINGS = {
            beginner: { noteSpeed: 8000, noteCount: 1 },
            novice: { noteSpeed: 8000, noteCount: 2 },
            intermediate: { noteSpeed: 8000, noteCount: 3 },
            advanced: { noteSpeed: 8000, noteCount: 4 },
            expert: { noteSpeed: 8000, noteCount: 5 },
            master: { noteSpeed: 8000, noteCount: 8 },
            legendary: { noteSpeed: 8000, noteCount: 11 },
            impossible: { noteSpeed: 8000, noteCount: 14 }
        };

        function getGameSettingsSummary() {
            let settings = [];
            
            // Mode
            settings.push(`<strong>Mode:</strong> ${gameState.gameMode === 'moving' ? 'Move' : 'Still'}`);
            
            // Difficulty (only if Move mode)
            if (gameState.gameMode === 'moving') {
                const difficultyName = gameState.difficulty.charAt(0).toUpperCase() + gameState.difficulty.slice(1);
                settings.push(`<strong>Difficulty:</strong> ${difficultyName}`);
            }
            
            // Notes type
            settings.push(`<strong>Notes:</strong> ${gameState.noteMode === 'scales' ? 'Scales' : 'Random'}`);
            
            // Key/Scale (only if Random notes mode)
            if (gameState.noteMode === 'random') {
                const scaleNames = {
                    'C': 'C Major', 'G': 'G Major', 'D': 'D Major', 'A': 'A Major', 'E': 'E Major',
                    'F': 'F Major', 'B': 'B Major', 'Am': 'A Minor', 'Em': 'E Minor', 
                    'Bm': 'B Minor', 'Dm': 'D Minor', 'Gm': 'G Minor', 'Cm': 'C Minor', 'Fm': 'F Minor'
                };
                const scaleName = scaleNames[gameState.selectedScale] || gameState.selectedScale;
                settings.push(`<strong>Key:</strong> ${scaleName}`);
            }
            
            // Region (only if Random notes mode)
            if (gameState.noteMode === 'random') {
                const regionNames = {
                    'above': 'Above Treble',
                    'treble': 'Treble Clef', 
                    'middle': 'Middle',
                    'bass': 'Bass Clef',
                    'below': 'Below Bass'
                };
                
                if (gameState.selectedRegions.length === 5) {
                    settings.push(`<strong>Region:</strong> All Regions`);
                } else {
                    const regionList = gameState.selectedRegions.map(r => regionNames[r] || r).join(', ');
                    settings.push(`<strong>Region:</strong> ${regionList}`);
                }
            }
            
            return settings.join('<br>');
        }


        // Initialize the game
        function initGame() {
            initializePiano(); // ADD THIS LINE
            createPianoKeys();
            updateDisplay();
            setupEventListeners();
            scaleClefSymbols();
            showStartScreen();
            console.log('Piano Learning Game initialized!');
        }

        function wrapStaffContent() {
            // Only run in landscape chord mode
            if (!document.body.classList.contains('landscape-mode-active')) {
                return;
            }
            
            const staffArea = document.querySelector('.staff-area');
            if (!staffArea) return;
            
            // Check if wrapper already exists
            let staffInner = staffArea.querySelector('.staff-inner');
            if (!staffInner) {
                // Create wrapper
                staffInner = document.createElement('div');
                staffInner.className = 'staff-inner';
                
                // Move all children into wrapper
                while (staffArea.firstChild) {
                    staffInner.appendChild(staffArea.firstChild);
                }
                
                // Add wrapper back to staff area
                staffArea.appendChild(staffInner);
            }
        }

        // Make functions globally accessible for the module
        window.playPianoKey = playPianoKey;
        window.playPianoSound = playPianoSound;
        window.createSupportNotes = createSupportNotes;
        window.generateChord = generateChord;

        // Add this after initGame() function
        window.addEventListener('resize', () => {
            setTimeout(scaleClefSymbols, 100); // Small delay to let layout settle
        });

        function calculateStaffSpacing() {
            const staffArea = document.querySelector('.staff-area');
            const isLandscapeChordMode = document.body.classList.contains('landscape-mode-active');
            
            // FIXED: Always use full height for calculations
            const staffHeight = isLandscapeChordMode ? 280 : staffArea.offsetHeight;
            const pixelsPerPosition = staffHeight / 48;
            const pixelsBetweenLines = pixelsPerPosition * 2;
            
            return {
                staffHeight: staffHeight,
                pixelsPerPosition: pixelsPerPosition,
                pixelsBetweenLines: pixelsBetweenLines
            };
        }

        function scaleClefSymbols() {
            const spacing = calculateStaffSpacing();
            const isLandscapeChordMode = document.body.classList.contains('landscape-mode-active');

            // Position treble clef with TOP at position 9
            const trebleClef = document.querySelector('.treble-clef');
            const trebleSpan = 6;
            const trebleHeight = spacing.pixelsBetweenLines * trebleSpan;

            trebleClef.style.width = trebleHeight + 'px';
            trebleClef.style.height = trebleHeight + 'px';
            
            if (isLandscapeChordMode) {
                // Use pixel positioning for landscape mode
                trebleClef.style.top = `${(9.2 - 1) * (280 / 48)}px`;
            } else {
                // Use percentage for normal mode
                trebleClef.style.top = `calc(${(9.2 - 1) * (100 / 48)}%)`;
            }
            trebleClef.style.transform = 'translateY(0)';

            // Position bass clef with TOP at position 29
            const bassClef = document.querySelector('.bass-clef');
            const bassSpan = 4;
            const bassHeight = spacing.pixelsBetweenLines * bassSpan;

            bassClef.style.width = bassHeight + 'px';
            bassClef.style.height = bassHeight + 'px';
            
            if (isLandscapeChordMode) {
                // Use pixel positioning for landscape mode
                bassClef.style.top = `${(30 - 1) * (280 / 48)}px`;
            } else {
                // Use percentage for normal mode
                bassClef.style.top = `calc(${(30 - 1) * (100 / 48)}%)`;
            }
            bassClef.style.transform = 'translateY(0)';
        }




        // Add support notes function:
        // Add support notes function:
        function createSupportNotes() {
            const container = document.getElementById('supportNotesContainer');
            container.innerHTML = '';
            
            // Bass support notes (F and C) - left column
            const bassNotes = [
                {note: 'F', octave: 1}, {note: 'C', octave: 2},
                {note: 'F', octave: 2}, {note: 'C', octave: 3}, 
                {note: 'F', octave: 3}, {note: 'C', octave: 4},
                {note: 'F', octave: 4}
            ];
            
            bassNotes.forEach(noteData => {
                const indicator = document.createElement('div');
                indicator.className = 'support-note-indicator bass-note';
                indicator.style.top = getNotePosition(noteData.note, noteData.octave, '_bass');
                indicator.textContent = noteData.note;
                indicator.title = noteData.note + noteData.octave;
                container.appendChild(indicator);
            });
            
            // Treble support notes (G and C) - right column
            const trebleNotes = [
                {note: 'G', octave: 6}, {note: 'C', octave: 6}, 
                {note: 'G', octave: 5}, {note: 'C', octave: 5}, 
                {note: 'G', octave: 4}, {note: 'C', octave: 4},
                {note: 'G', octave: 3}, 
            ];
            
            trebleNotes.forEach(noteData => {
                const indicator = document.createElement('div');
                indicator.className = 'support-note-indicator treble-note';
                indicator.style.top = getNotePosition(noteData.note, noteData.octave, '_treble');
                indicator.textContent = noteData.note;
                indicator.title = noteData.note + noteData.octave;
                container.appendChild(indicator);
            });
        }

        function createPianoKeys() {
            const pianoKeys = document.getElementById('pianoKeys');
            pianoKeys.innerHTML = '';

            // Add toggle button
            const toggleButton = document.createElement('div');
            toggleButton.className = 'key-labels-toggle';
            toggleButton.innerHTML = '👁';
            toggleButton.title = 'Toggle key labels';
            
            let labelsVisible = false; // Default to hidden
            toggleButton.addEventListener('click', () => {
                labelsVisible = !labelsVisible;
                const allKeys = pianoKeys.querySelectorAll('.key');
                allKeys.forEach(key => {
                    if (labelsVisible) {
                        key.style.color = key.classList.contains('white-key') ? 'black' : 'white';
                    } else {
                        key.style.color = 'transparent';
                    }
                });
                toggleButton.style.opacity = labelsVisible ? '1' : '0.5';
            });
            
            pianoKeys.appendChild(toggleButton);


            // Add this to createPianoKeys() function after the existing toggle button:
            const supportNotesToggle = document.createElement('div');
            supportNotesToggle.className = 'support-notes-toggle';
            supportNotesToggle.innerHTML = '-c-';
            supportNotesToggle.title = 'Toggle support notes';

            let supportNotesVisible = false;
            supportNotesToggle.addEventListener('click', () => {
                supportNotesVisible = !supportNotesVisible;
                const container = document.getElementById('supportNotesContainer');
                if (supportNotesVisible) {
                    container.classList.add('active');
                    createSupportNotes();
                } else {
                    container.classList.remove('active');
                }
                supportNotesToggle.style.opacity = supportNotesVisible ? '1' : '0.5';
            });

            pianoKeys.appendChild(supportNotesToggle);

            // Add sound toggle button on the right side
            const soundToggle = document.createElement('div');
            soundToggle.className = 'sound-toggle';
            soundToggle.innerHTML = '♪';  // Musical note symbol
            soundToggle.title = 'Toggle sound on/off';

            let soundEnabled = true; // Default on
            soundToggle.addEventListener('click', () => {
                window.soundEnabled = !window.soundEnabled;
                if (window.soundEnabled) {
                    soundToggle.innerHTML = '♪';
                    soundToggle.style.opacity = '0.5';
                } else {
                    soundToggle.innerHTML = '🔇';
                    soundToggle.style.opacity = '0.5';
                }
            });
            

            pianoKeys.appendChild(soundToggle);





            // Create white keys
            const WHITE_KEYS = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            WHITE_KEYS.forEach(note => {
                const key = document.createElement('div');
                key.className = 'key white-key';
                key.textContent = note;
                key.dataset.note = note;
                                
                key.addEventListener('click', () => {
                    playPianoKey(note);
                    
                });

                // In createPianoKeys(), replace the touch event listeners:
                key.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    key.classList.add('pressed');
                    playPianoKey(note);
                    

                });

                key.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    key.classList.remove('pressed');
                });
                
                pianoKeys.appendChild(key);

                // Add black keys
                if (['C', 'D', 'F', 'G', 'A'].includes(note)) {
                    const blackNote = note + '#';
                    const blackKey = document.createElement('div');
                    blackKey.className = 'key black-key';
                    
                    const enharmonics = getEnharmonicEquivalents(blackNote);
                    if (enharmonics.length > 1) {
                        blackKey.innerHTML = enharmonics.join('<br>');
                    } else {
                        blackKey.textContent = blackNote;
                    }
                    
                    blackKey.dataset.note = blackNote;
                    
                    blackKey.addEventListener('click', () => {
                        playPianoKey(blackNote);
                        
                    });
                                    // Do the same for black keys:
                    blackKey.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        blackKey.classList.add('pressed');
                        playPianoKey(blackNote);
                        
                    });

                    blackKey.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        blackKey.classList.remove('pressed');
                    });
                    
                    pianoKeys.appendChild(blackKey);
                } 
            });
        }

        function setupEventListeners() {
            // Column 1: Note Types (mutually exclusive)
            document.getElementById('notesToggle').addEventListener('change', function() {
                if (gameState.isPlaying) {
                    this.checked = !this.checked;
                    return;
                }
                
                if (this.checked) {
                    // Turn off other note types
                    document.getElementById('scalesToggle').checked = false;
                    document.getElementById('chordsToggle').checked = false;
                    
                    // Update labels
                    document.querySelector('.notes-label').style.color = '#333';
                    document.querySelector('.scales-label').style.color = '#999';
                    document.querySelector('.chords-label').style.color = '#999';
                    
                    // Set game state
                    gameState.noteMode = 'random';
                    gameState.chordMode = false;
                    
                    // Enable dropdowns
                    document.getElementById('regionDropdown').style.opacity = '1';
                    document.getElementById('regionDropdown').style.pointerEvents = 'auto';
                    document.getElementById('keyDropdown').style.opacity = '1';
                    document.getElementById('keyDropdown').style.pointerEvents = 'auto';
                } else {
                    // If notes is unchecked, auto-check scales
                    document.getElementById('scalesToggle').checked = true;
                    document.querySelector('.scales-label').style.color = '#333';
                    document.querySelector('.notes-label').style.color = '#999';
                    gameState.noteMode = 'scales';
                    gameState.chordMode = false;
                    
                    // Disable dropdowns for scales
                    document.getElementById('regionDropdown').style.opacity = '0.5';
                    document.getElementById('regionDropdown').style.pointerEvents = 'none';
                    document.getElementById('keyDropdown').style.opacity = '0.5';
                    document.getElementById('keyDropdown').style.pointerEvents = 'none';
                }
            });

            document.getElementById('scalesToggle').addEventListener('change', function() {
                if (gameState.isPlaying) {
                    this.checked = !this.checked;
                    return;
                }
                
                if (this.checked) {
                    // Turn off other note types
                    document.getElementById('notesToggle').checked = false;
                    document.getElementById('chordsToggle').checked = false;
                    
                    // Update labels
                    document.querySelector('.scales-label').style.color = '#333';
                    document.querySelector('.notes-label').style.color = '#999';
                    document.querySelector('.chords-label').style.color = '#999';
                    
                    // Set game state
                    gameState.noteMode = 'scales';
                    gameState.chordMode = false;

                    // Enable region dropdown for scales, disable key dropdown
                    document.getElementById('regionDropdown').style.opacity = '1';
                    document.getElementById('regionDropdown').style.pointerEvents = 'auto';
                    document.getElementById('keyDropdown').style.opacity = '0.5';
                    document.getElementById('keyDropdown').style.pointerEvents = 'none';
                                    } else {
                    // If scales is unchecked, auto-check notes
                    document.getElementById('notesToggle').checked = true;
                    document.querySelector('.notes-label').style.color = '#333';
                    document.querySelector('.scales-label').style.color = '#999';
                    gameState.noteMode = 'random';
                    gameState.chordMode = false;
                    
                    // Enable dropdowns
                    document.getElementById('regionDropdown').style.opacity = '1';
                    document.getElementById('regionDropdown').style.pointerEvents = 'auto';
                    document.getElementById('keyDropdown').style.opacity = '1';
                    document.getElementById('keyDropdown').style.pointerEvents = 'auto';
                }
            });

            document.getElementById('chordsToggle').addEventListener('change', function() {
                if (gameState.isPlaying) {
                    this.checked = !this.checked;
                    return;
                }
                
                if (this.checked) {
                    // Turn off other note types
                    document.getElementById('notesToggle').checked = false;
                    document.getElementById('scalesToggle').checked = false;
                    
                    // Update labels
                    document.querySelector('.chords-label').style.color = '#333';
                    document.querySelector('.notes-label').style.color = '#999';
                    document.querySelector('.scales-label').style.color = '#999';
                    
                    // Set game state
                    gameState.chordMode = true;
                    gameState.noteMode = 'random';
                    
                    // Enable dropdowns for chords
                    document.getElementById('regionDropdown').style.opacity = '1';
                    document.getElementById('regionDropdown').style.pointerEvents = 'auto';
                    document.getElementById('keyDropdown').style.opacity = '0.5';
                    document.getElementById('keyDropdown').style.pointerEvents = 'none';
                } else {
                    // If chords is unchecked, auto-check notes
                    document.getElementById('notesToggle').checked = true;
                    document.querySelector('.notes-label').style.color = '#333';
                    document.querySelector('.chords-label').style.color = '#999';
                    gameState.noteMode = 'random';
                    gameState.chordMode = false;
                    
                    // Enable dropdowns
                    document.getElementById('regionDropdown').style.opacity = '1';
                    document.getElementById('regionDropdown').style.pointerEvents = 'auto';
                    document.getElementById('keyDropdown').style.opacity = '1';
                    document.getElementById('keyDropdown').style.pointerEvents = 'auto';
                }
            });

            // Column 2: Game Modes (mutually exclusive)
            document.getElementById('gameModeToggle').addEventListener('change', function() {
                if (gameState.isPlaying) {
                    this.checked = !this.checked;
                    return;
                }
                
                if (this.checked) {
                    // Turn off still mode
                    document.getElementById('stillToggle').checked = false;
                    
                    // Update labels
                    document.querySelector('.move-label').style.color = '#333';
                    document.querySelector('.still-label').style.color = '#999';
                    
                    // Set game state
                    gameState.gameMode = 'moving';
                    
                    // Enable difficulty
                    document.getElementById('levelDropdown').style.opacity = '1';
                    document.getElementById('levelDropdown').style.pointerEvents = 'auto';
                } else {
                    // If move is unchecked, auto-check still
                    document.getElementById('stillToggle').checked = true;
                    document.querySelector('.still-label').style.color = '#333';
                    document.querySelector('.move-label').style.color = '#999';
                    gameState.gameMode = 'still';
                    
                    // Disable difficulty for still mode
                    document.getElementById('levelDropdown').style.opacity = '0.5';
                    document.getElementById('levelDropdown').style.pointerEvents = 'none';
                    document.getElementById('difficulty').textContent = 'Still';
                }
            });

            document.getElementById('stillToggle').addEventListener('change', function() {
                if (gameState.isPlaying) {
                    this.checked = !this.checked;
                    return;
                }
                
                if (this.checked) {
                    // Turn off move mode
                    document.getElementById('gameModeToggle').checked = false;
                    
                    // Update labels
                    document.querySelector('.still-label').style.color = '#333';
                    document.querySelector('.move-label').style.color = '#999';
                    
                    // Set game state
                    gameState.gameMode = 'still';
                    
                    // Disable difficulty for still mode
                    document.getElementById('levelDropdown').style.opacity = '0.5';
                    document.getElementById('levelDropdown').style.pointerEvents = 'none';
                    document.getElementById('difficulty').textContent = 'Still';
                } else {
                    // If still is unchecked, auto-check move
                    document.getElementById('gameModeToggle').checked = true;
                    document.querySelector('.move-label').style.color = '#333';
                    document.querySelector('.still-label').style.color = '#999';
                    gameState.gameMode = 'moving';
                    
                    // Enable difficulty
                    document.getElementById('levelDropdown').style.opacity = '1';
                    document.getElementById('levelDropdown').style.pointerEvents = 'auto';
                }
            });

            // Column 3: Dropdowns (same as before)
            document.getElementById('levelDropdown').addEventListener('click', function() {
                if (gameState.isPlaying) return;
                
                const select = document.getElementById('difficultySelect');
                const options = Array.from(select.options).map(opt => ({value: opt.value, text: opt.text}));
                showDropdownMenu(this, options, (value) => {
                    select.value = value;
                    this.querySelector('.dropdown-text').textContent = select.options[select.selectedIndex].text;
                    gameState.difficulty = value;
                    document.getElementById('difficulty').textContent = 
                        value.charAt(0).toUpperCase() + value.slice(1);
                });
            });

            document.getElementById('regionDropdown').addEventListener('click', function() {
                if (gameState.isPlaying) return;
                
                const select = document.getElementById('regionSelect');
                let options;
                
                // Different options for scales vs notes/chords
                // Different options for scales vs notes/chords
                if (gameState.noteMode === 'scales') {
                    options = [
                        {value: 'all', text: 'All Regions'},
                        {value: 'treble', text: 'Treble Clef'},
                        {value: 'bass', text: 'Bass Clef'}
                    ];
                } else {
                    options = Array.from(select.options).map(opt => ({value: opt.value, text: opt.text}));
                }
                
                showDropdownMenu(this, options, (value) => {
                    select.value = value;
                    this.querySelector('.dropdown-text').textContent = 
                        options.find(opt => opt.value === value)?.text || value;
                    
                    if (gameState.noteMode === 'scales') {
                        // For scales, handle all regions or specific clef
                        if (value === 'all') {
                            gameState.selectedRegions = ['treble', 'bass']; // Both clefs for scales
                        } else {
                            gameState.selectedRegions = [value];
                        }
                    } else {
                        // For notes/chords, use existing logic
                        if (value === 'all') {
                            gameState.selectedRegions = ['above', 'treble', 'middle', 'bass', 'below'];
                        } else {
                            gameState.selectedRegions = value.split(',');
                        }
                    }
                });
            });

            document.getElementById('keyDropdown').addEventListener('click', function() {
                if (gameState.isPlaying) return;
                
                const select = document.getElementById('scale');
                const options = Array.from(select.options).map(opt => ({value: opt.value, text: opt.text}));
                showDropdownMenu(this, options, (value) => {
                    select.value = value;
                    this.querySelector('.dropdown-text').textContent = select.options[select.selectedIndex].text;
                    gameState.selectedScale = value;
                    displayKeySignature(value);
                });
            });

            displayKeySignature(gameState.selectedScale);
        }

        function showDropdownMenu(element, options, callback) {
            // Remove any existing dropdown
            const existing = document.querySelector('.dropdown-menu');
            if (existing) existing.remove();
            
            const menu = document.createElement('div');
            menu.className = 'dropdown-menu';
            menu.style.cssText = `
                position: absolute;
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                min-width: 150px;
                max-height: 200px;
                overflow-y: auto;
            `;
            
            options.forEach(option => {
                const item = document.createElement('div');
                item.textContent = option.text;
                item.style.cssText = `
                    padding: 12px 16px;
                    cursor: pointer;
                    border-bottom: 1px solid #eee;
                `;
                item.addEventListener('click', () => {
                    callback(option.value);
                    menu.remove();
                });
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#f0f0f0';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = 'white';
                });
                menu.appendChild(item);
            });
            
            const rect = element.getBoundingClientRect();
            menu.style.top = (rect.bottom + window.scrollY) + 'px';
            menu.style.left = rect.left + 'px';
            
            document.body.appendChild(menu);
            
            // Close on outside click
            
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 10);
        }

        function showStartScreen() {
            gameState.isPlaying = false;
            document.getElementById('gameStartOverlay').style.display = 'flex';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('endGameBtn').style.display = 'none';
            document.getElementById('notesToggle').disabled = false;
            document.getElementById('scalesToggle').disabled = false;
            document.getElementById('chordsToggle').disabled = false;
            document.getElementById('gameModeToggle').disabled = false;
            document.getElementById('stillToggle').disabled = false;
            document.getElementById('regionSelect').disabled = false;
            //document.getElementById('noteModeToggle').disabled = false;
            document.getElementById('currentScaleDisplay').style.display = 'none';
            document.getElementById('scaleInfoContainer').style.display = 'none';
            document.getElementById('scaleInfoContainer').style.display = 'none';
            // Clear any old scale info
            document.getElementById('currentScaleDisplay').textContent = '';
            document.getElementById('scaleInfoContainer').style.display = 'none';
            // Clear old accidentals
            const trebleStaff = document.getElementById('miniTrebleStaff');
            const bassStaff = document.getElementById('miniBassStaff');

            ClefSwitchingModule.enableButton();
            
            if (trebleStaff && bassStaff) {
                trebleStaff.querySelectorAll('div').forEach(div => {
                    if (div.textContent === '♯' || div.textContent === '♭') {
                        div.remove();
                    }
                });
                bassStaff.querySelectorAll('div').forEach(div => {
                    if (div.textContent === '♯' || div.textContent === '♭') {
                        div.remove();
                    }
                });
            }
            
            // Clear any existing notes
            const existingNotes = document.querySelectorAll('.moving-note');
            existingNotes.forEach(note => note.remove());
            
            const stillContainer = document.getElementById('stillNotesContainer');
            stillContainer.classList.remove('active');
            stillContainer.innerHTML = '';
            // Reset display areas
            // Reset display areas
            document.getElementById('scaleDisplay').style.display = 'none';
            document.getElementById('wrongNoteDisplay').style.display = 'none';
            // Reset progress bar
            document.getElementById('progressBar').style.width = '0%';


            // Re-enable game configuration buttons
            document.getElementById('scale').disabled = false;
            document.getElementById('difficultySelect').disabled = false;
            document.getElementById('notesToggle').disabled = false;
            document.getElementById('scalesToggle').disabled = false;
            document.getElementById('chordsToggle').disabled = false;
            document.getElementById('gameModeToggle').disabled = false;
            document.getElementById('stillToggle').disabled = false;
            document.getElementById('regionSelect').disabled = false; // ADD THIS LINE

        }

        function endGame() {
            gameState.isPlaying = false;
            
            // Clear all existing timeouts to stop note generation
            for (let i = 1; i < 99999; i++) {
                window.clearTimeout(i);
            }
            
            // Remove all active notes from the screen
            const existingNotes = document.querySelectorAll('.moving-note');
            existingNotes.forEach(note => note.remove());
            
            // Clear active notes array
            gameState.activeNotes = [];
            
            // Clear still notes
            const stillContainer = document.getElementById('stillNotesContainer');
            stillContainer.classList.remove('active');
            stillContainer.innerHTML = '';
            gameState.stillNotes = [];
            
            // Hide end game button
            document.getElementById('notesToggle').disabled = false;
            document.getElementById('scalesToggle').disabled = false;
            document.getElementById('chordsToggle').disabled = false;
            document.getElementById('gameModeToggle').disabled = false;
            document.getElementById('stillToggle').disabled = false;

            // Re-enable game configuration buttons
            document.getElementById('scale').disabled = false;
            document.getElementById('difficultySelect').disabled = false;
            document.getElementById('notesToggle').disabled = false;
            document.getElementById('scalesToggle').disabled = false;
            document.getElementById('chordsToggle').disabled = false;
            document.getElementById('gameModeToggle').disabled = false;
            document.getElementById('stillToggle').disabled = false;

            // Hide end game button
            document.getElementById('endGameBtn').style.display = 'none';

            // Hide scale display when game ends
            document.getElementById('scaleInfoContainer').style.display = 'none';

            
            // Show start screen
            showStartScreen();
        }


        function generateNote() {

            
            const allowedSections = gameState.selectedRegions;

            let availableNotes = [];
            let selectedSection = '';
            
            // If all regions are selected, use original weighted random selection
            if (allowedSections.length === 5) {
                const staffSections = {
                    aboveBelow: 0.15,
                    between: 0.15,
                    treble: 0.35,
                    bass: 0.35
                };
                
                const random = Math.random();
                
                if (random < staffSections.aboveBelow) {
                    selectedSection = 'aboveBelow';
                } else if (random < staffSections.aboveBelow + staffSections.between) {
                    selectedSection = 'between';
                } else if (random < staffSections.aboveBelow + staffSections.between + staffSections.treble) {
                    selectedSection = 'treble';
                } else {
                    selectedSection = 'bass';
                }
                
                const allNoteKeys = Object.keys(NOTE_POSITIONS);
                
                switch (selectedSection) {
                    case 'aboveBelow':
                        availableNotes = allNoteKeys.filter(key => {
                            const position = NOTE_POSITIONS[key];
                            return position <= 10 || position >= 40;
                        });
                        break;
                    case 'between':
                        availableNotes = allNoteKeys.filter(key => {
                            const position = NOTE_POSITIONS[key];
                            return position >= 20 && position <= 30;
                        });
                        break;
                    case 'treble':
                        availableNotes = allNoteKeys.filter(key => {
                            const position = NOTE_POSITIONS[key];
                            return position >= 11 && position <= 19;
                        });
                        break;
                    case 'bass':
                        availableNotes = allNoteKeys.filter(key => {
                            const position = NOTE_POSITIONS[key];
                            return position >= 31 && position <= 39;
                        });
                        break;
                }
            } else {
                
                // Filter notes based on selected regions only
                const allNoteKeys = Object.keys(NOTE_POSITIONS);
                
                allNoteKeys.forEach(key => {
                    const position = NOTE_POSITIONS[key];
                    if ((allowedSections.includes('above') && position <= 10) ||
                        (allowedSections.includes('treble') && position >= 11 && position <= 19) ||
                        (allowedSections.includes('middle') && position >= 20 && position <= 30) ||
                        (allowedSections.includes('bass') && position >= 31 && position <= 39) ||
                        (allowedSections.includes('below') && position >= 40)) {
                        availableNotes.push(key);
                    }
                });
                
                // Set selectedSection based on what's actually selected (for area tracking)
                if (allowedSections.includes('treble')) {
                    selectedSection = 'treble';
                } else if (allowedSections.includes('bass')) {
                    selectedSection = 'bass';
                } else if (allowedSections.includes('middle')) {
                    selectedSection = 'between';
                } else {
                    selectedSection = 'aboveBelow';
                }
            }
            
            if (availableNotes.length === 0) {
                availableNotes = Object.keys(NOTE_POSITIONS);
            }
            
            const randomKey = availableNotes[Math.floor(Math.random() * availableNotes.length)];
            const match = randomKey.match(/([A-G][#b]?)(\d+)(_treble|_bass)?/);
            if (!match) {
                return { note: 'C', octave: 4, hand: '', fullKey: 'C4', accidental: null };
            }
            
            let baseNote = match[1];
            const octave = parseInt(match[2]);
            const hand = match[3] || '';
            
            const scaleAdjustedNote = getScaleNote(baseNote.charAt(0), gameState.selectedScale);
            
            let accidental = null;
            if (Math.random() < 0.3) {
                const noteLetter = baseNote.charAt(0);
                const noteHasAccidental = scaleAdjustedNote.includes('#') || scaleAdjustedNote.includes('b');
                
                if (noteHasAccidental) {
                    accidental = 'natural';
                } else {
                    const validAccidentals = [];
                    
                    if (!['E', 'B'].includes(noteLetter)) {
                        validAccidentals.push('sharp');
                    }
                    
                    if (!['F', 'C'].includes(noteLetter)) {
                        validAccidentals.push('flat');
                    }
                    
                    if (validAccidentals.length > 0) {
                        accidental = validAccidentals[Math.floor(Math.random() * validAccidentals.length)];
                    }
                }
            }
            
            return { 
                note: baseNote.charAt(0),
                scaleNote: scaleAdjustedNote,
                octave: octave,
                hand: hand,
                fullKey: randomKey,
                accidental: accidental,
                area: selectedSection
            };
        }


        function generateScaleNote() {
            // Initialize scale state if not exists
            if (!gameState.currentScale) {
                gameState.currentScale = {
                    notes: [],
                    currentIndex: 0,
                    clef: null,
                    scaleName: null
                };
            }
            
            // If we need a new scale (first time or finished previous scale)
            if (gameState.currentScale.notes.length === 0 || 
                gameState.currentScale.currentIndex >= gameState.currentScale.notes.length) {
                
                // Use selected region if available, otherwise random
                let clef;
                if (gameState.selectedRegions && gameState.selectedRegions.length === 1) {
                    const selectedRegion = gameState.selectedRegions[0];
                    if (selectedRegion === 'treble' || selectedRegion === 'bass') {
                        clef = selectedRegion;
                    } else {
                        clef = Math.random() < 0.5 ? 'treble' : 'bass';
                    }
                } else {
                    clef = Math.random() < 0.5 ? 'treble' : 'bass';
                }
                
                // Get random scale
                const scaleKeys = Object.keys(SCALES);
                const randomScale = scaleKeys[Math.floor(Math.random() * scaleKeys.length)];
                const scaleNotes = SCALES[randomScale];
                
                // Set starting octave based on clef
                const startingOctave = (clef === 'treble') ? 4 : 2;
                
                // Build the scale sequence with proper octave progression
                const sequence = [];
                let currentOctave = startingOctave;
                
                for (let i = 0; i < 7; i++) {
                    const scaleNote = scaleNotes[i]; // Full note: 'G', 'F#', 'Bb', etc.
                    const noteLetter = scaleNote.charAt(0); // Just letter: 'G', 'F', 'B'
                    
                    // Handle octave increment: B to C goes up an octave
                    if (i > 0) {
                        const prevLetter = scaleNotes[i-1].charAt(0);
                        if (prevLetter === 'B' && noteLetter === 'C') {
                            currentOctave++;
                        }
                    }
                    
                    // Determine hand marking and position key
                    let hand = '';
                    let positionKey = noteLetter + currentOctave;
                    
                    if (clef === 'treble') {
                        // For treble: C4 and D4 need _treble suffix
                        if (currentOctave === 4 && (noteLetter === 'C' || noteLetter === 'D')) {
                            hand = '_treble';
                            positionKey = noteLetter + currentOctave + '_treble';
                        }
                    } else if (clef === 'bass') {
                        // For bass: C4 and B3 need _bass suffix  
                        if ((currentOctave === 4 && noteLetter === 'C') || 
                            (currentOctave === 3 && noteLetter === 'B')) {
                            hand = '_bass';
                            positionKey = noteLetter + currentOctave + '_bass';
                        }
                    }
                    
                    // Verify this position exists
                    if (!NOTE_POSITIONS[positionKey]) {
                        return generateNote(); // Fallback
                    }
                    
                    // Determine accidental for display
                    let accidental = null;
                    if (scaleNote.includes('#')) {
                        accidental = 'sharp';
                    } else if (scaleNote.includes('b')) {
                        accidental = 'flat';
                    }
                    
                    sequence.push({
                        note: noteLetter,           
                        scaleNote: scaleNote,       
                        octave: currentOctave,      
                        hand: hand,                 
                        fullKey: positionKey,       
                        accidental: accidental,     
                        area: clef,                 
                        scale: randomScale
                    });
                }
                
                // Store the completed scale
                gameState.currentScale.notes = sequence;
                gameState.currentScale.currentIndex = 0;
                gameState.currentScale.clef = clef;
                gameState.currentScale.scaleName = randomScale;
                
                // Show scale name
                const scaleNames = {
                    'C': 'C Major', 'G': 'G Major', 'D': 'D Major', 'A': 'A Major', 'E': 'E Major',
                    'F': 'F Major', 'B': 'B Major', 'Am': 'A Minor', 'Em': 'E Minor', 
                    'Bm': 'B Minor', 'Dm': 'D Minor', 'Gm': 'G Minor', 'Cm': 'C Minor', 'Fm': 'F Minor'
                };
                const displayName = scaleNames[randomScale] || randomScale;
                
                document.getElementById('currentScaleDisplay').textContent = `Scale: ${displayName}`;
                document.getElementById('scaleInfoContainer').style.display = 'block';
                document.getElementById('currentScaleDisplay').style.display = 'block';
                displayMiniKeySignature(randomScale);
            }
            
            // Get next note in sequence
            const selectedNote = gameState.currentScale.notes[gameState.currentScale.currentIndex];
            gameState.currentScale.currentIndex++;
            
            return {
                note: selectedNote.note,               
                scaleNote: selectedNote.scaleNote,      
                octave: selectedNote.octave,
                hand: selectedNote.hand,              
                fullKey: selectedNote.fullKey,
                accidental: selectedNote.accidental,
                area: selectedNote.area,
                scale: selectedNote.scale
            };
        }

        function createNoteElement(noteData, isStill = false) {
            if (noteData.isChord) {
                return createChordElement(noteData, isStill);
            }
            
            // Existing single note code remains the same...
            const noteElement = document.createElement('div');
            noteElement.className = isStill ? 'still-note' : 'moving-note';
            
            // Create note head
            const noteHead = document.createElement('div');
            noteHead.className = 'note-head';
            noteElement.appendChild(noteHead);
            
            // Create stem
            const stem = document.createElement('div');
            stem.className = 'note-stem';
            
            // Determine stem direction and middle region based on position and hand
            const position = NOTE_POSITIONS[noteData.fullKey] || NOTE_POSITIONS[noteData.note + noteData.octave];
            const isMiddleRegion = position >= 20 && position <= 30; // Between staves
            
            if (isMiddleRegion) {
                // In middle region, stem direction depends on hand
                if (noteData.hand === '_bass' || noteData.fullKey.includes('_bass')) {
                    stem.classList.add('stem-down', 'middle-region');
                } else if (noteData.hand === '_treble' || noteData.fullKey.includes('_treble')) {
                    stem.classList.add('stem-up', 'middle-region');
                } else {
                    // Default to treble for notes without explicit hand marking
                    stem.classList.add('stem-up', 'middle-region');
                }
            } else {
                // Outside middle region, use traditional stem direction
                if (position <= 25) { // Higher notes - stem down
                    stem.classList.add('stem-down');
                } else { // Lower notes - stem up
                    stem.classList.add('stem-up');
                }
            }
            
            noteElement.appendChild(stem);
            
            // Position the note
            noteElement.style.top = getNotePosition(noteData.note, noteData.octave, noteData.hand || '');
            noteElement.style.transform = 'translateY(-50%)';
            // Add ledger lines if needed
            const ledgerInfo = needsLedgerLines(position);
            addLedgerLines(noteElement, ledgerInfo);

            
            // Store note data
            noteElement.noteData = {
                note: noteData.note,
                scaleNote: noteData.scaleNote,
                accidental: noteData.accidental,
                octave: noteData.octave,
                hand: noteData.hand,
                area: noteData.area,  // Add this line
                guessed: false
            };
            
            // Add accidental if needed
            if (noteData.accidental) {
                const accidentalElement = document.createElement('div');
                accidentalElement.style.position = 'absolute';
                accidentalElement.style.right = '20px'; // Closer to note
                accidentalElement.style.top = '50%';
                accidentalElement.style.transform = 'translateY(-50%)';
                accidentalElement.style.fontSize = '16px';
                accidentalElement.style.color = 'black';
                accidentalElement.style.zIndex = '11';
                accidentalElement.style.fontWeight = 'bold';
                
                switch (noteData.accidental) {
                    case 'sharp': accidentalElement.textContent = '♯'; break;
                    case 'flat': 
                        accidentalElement.textContent = '♭'; 
                        accidentalElement.style.top = 'calc(50% - 3px)';
                        break;
                    case 'natural': accidentalElement.textContent = '♮'; break;
                }
                
                noteElement.appendChild(accidentalElement);
            }
            
            return noteElement;
        }

        function createChordElement(chordData, isStill = false) {
            const chordContainer = document.createElement('div');
            chordContainer.className = isStill ? 'still-note chord-container' : 'moving-note chord-container';
            
            // Position container at the average position of all notes
            const avgPosition = chordData.notes.reduce((sum, note) => sum + NOTE_POSITIONS[note.fullKey], 0) / chordData.notes.length;
            chordContainer.style.top = `calc(${avgPosition - 1} * (100% / 48))`;
            chordContainer.style.transform = 'translateY(-50%)';
            
            // FIRST: Calculate stem direction
            const staffMiddle = chordData.clef === 'treble' ? 14 : 34;
            let furthestDistance = 0;
            let furthestPosition = 0;
            
            chordData.notes.forEach(noteInfo => {
                const position = NOTE_POSITIONS[noteInfo.fullKey];
                const distance = Math.abs(position - staffMiddle);
                if (distance > furthestDistance) {
                    furthestDistance = distance;
                    furthestPosition = position;
                }
            });
            
            // THEN: Create each note with ledger lines
            chordData.notes.forEach((noteInfo, index) => {
                const noteElement = document.createElement('div');
                noteElement.className = 'chord-note';
                noteElement.style.position = 'absolute';
                noteElement.style.width = '18px';
                noteElement.style.height = '14px';
                
                // Create note head
                const noteHead = document.createElement('div');
                noteHead.className = 'note-head';
                noteElement.appendChild(noteHead);

                // ADD ACCIDENTALS for chord notes
                const chordNote = chordData.notes.find(n => n.fullKey === noteInfo.fullKey);
                if (chordNote && chordNote.note.includes('#')) {
                    const accidentalElement = document.createElement('div');
                    accidentalElement.style.position = 'absolute';
                    accidentalElement.style.right = '20px';
                    accidentalElement.style.top = '50%';
                    accidentalElement.style.transform = 'translateY(-50%)';
                    accidentalElement.style.fontSize = '16px';
                    accidentalElement.style.color = 'black';
                    accidentalElement.style.zIndex = '11';
                    accidentalElement.style.fontWeight = 'bold';
                    accidentalElement.textContent = '♯';
                    noteElement.appendChild(accidentalElement);
                } else if (chordNote && chordNote.note.includes('b')) {
                    // Similar for flats
                    const accidentalElement = document.createElement('div');
                    accidentalElement.style.position = 'absolute';
                    accidentalElement.style.right = '20px';
                    accidentalElement.style.top = 'calc(50% - 3px)';
                    accidentalElement.style.transform = 'translateY(-50%)';
                    accidentalElement.style.fontSize = '16px';
                    accidentalElement.style.color = 'black';
                    accidentalElement.style.zIndex = '11';
                    accidentalElement.style.fontWeight = 'bold';
                    accidentalElement.textContent = '♭';
                    noteElement.appendChild(accidentalElement);
                }

                
                // Position relative to container
                const relativePosition = NOTE_POSITIONS[noteInfo.fullKey] - avgPosition;
                const staffHeight = 280;
                const pixelsPerPosition = staffHeight / 48;
                noteElement.style.top = (relativePosition * pixelsPerPosition) + 'px';
                
                // ADD HORIZONTAL OFFSET FOR ADJACENT NOTES
                let horizontalOffset = 0;
                if (index > 0) {
                    const currentPos = NOTE_POSITIONS[noteInfo.fullKey];
                    const prevPos = NOTE_POSITIONS[chordData.notes[index - 1].fullKey];
                    
                    // If notes are adjacent (1 position apart), offset them
                    if (Math.abs(currentPos - prevPos) === 1) {
                        // Don't shift the top note (first) or bottom note (last)
                        const isTopNote = (index === 0);
                        const isBottomNote = (index === chordData.notes.length - 1);
                        
                        if (!isTopNote && !isBottomNote) {
                            // Determine stem direction (calculate it same way as main stem)
                            // We need to know the final stemDirection here
                            let chordStemDirection = 'up'; // default
                            
                            // Copy the same logic used for main stem direction
                            if (avgPosition >= 11 && avgPosition <= 19) {
                                // Treble logic
                                const notePositions = chordData.notes.map(note => NOTE_POSITIONS[note.fullKey]);
                                const trebleCenterLine = 14;
                                const notesAboveCenter = notePositions.filter(pos => pos < trebleCenterLine).length;
                                const notesBelowCenter = notePositions.filter(pos => pos > trebleCenterLine).length;
                                chordStemDirection = (notesAboveCenter > notesBelowCenter) ? 'up' : 'down';
                            } else if (avgPosition >= 31 && avgPosition <= 39) {
                                // Bass logic  
                                const notePositions = chordData.notes.map(note => NOTE_POSITIONS[note.fullKey]);
                                const bassCenterLine = 34;
                                const notesAboveCenter = notePositions.filter(pos => pos < bassCenterLine).length;
                                const notesBelowCenter = notePositions.filter(pos => pos > bassCenterLine).length;
                                chordStemDirection = (notesAboveCenter > notesBelowCenter) ? 'up' : 'down';
                            } else if (avgPosition >= 18 && avgPosition <= 32) {
                                // Middle region
                                chordStemDirection = (chordData.clef === 'treble') ? 'down' : 'up';
                            } else if (avgPosition <= 10) {
                                chordStemDirection = 'up';
                            } else {
                                chordStemDirection = 'down';
                            }
                            
                            // Apply offset based on stem direction
                            if (chordStemDirection === 'down') {
                                horizontalOffset = -12; // Left side (opposite of stem)
                            } else {
                                horizontalOffset = 12;  // Right side (opposite of stem)
                            }
                        }
                    }
                }

                noteElement.style.left = horizontalOffset + 'px';

                // Add ledger lines if needed (now furthestPosition is available)
                const ledgerInfo = needsLedgerLines(NOTE_POSITIONS[noteInfo.fullKey]);
                if (ledgerInfo) {
                    const tempStem = document.createElement('div');
                    tempStem.className = 'note-stem';
                    if (furthestPosition < staffMiddle) {
                        tempStem.classList.add('stem-down');
                    } else {
                        tempStem.classList.add('stem-up');
                    }
                    noteElement.appendChild(tempStem);
                    addLedgerLines(noteElement, ledgerInfo);
                    noteElement.removeChild(tempStem);
                }
                
                chordContainer.appendChild(noteElement);
            });
            
            // Add the single stem for the entire chord
            // Add the single stem for the entire chord
            const stem = document.createElement('div');
            stem.className = 'note-stem';

            // Define center lines
            const trebleCenterLine = 14; // G line in treble clef
            const bassCenterLine = 34;   // D line in bass clef

            // Find the highest and lowest note positions
            const notePositions = chordData.notes.map(note => NOTE_POSITIONS[note.fullKey]);
            const highestPos = Math.min(...notePositions); // Lower number = higher on staff
            const lowestPos = Math.max(...notePositions);  // Higher number = lower on staff

            const staffHeight = 280;
            const pixelsPerPosition = staffHeight / 48;

            let stemDirection = 'up'; // default

            // Determine which region and stem direction
            if (avgPosition >= 11 && avgPosition <= 19) {
                // Treble clef region
                const notesAboveCenter = notePositions.filter(pos => pos < trebleCenterLine).length;
                const notesBelowCenter = notePositions.filter(pos => pos > trebleCenterLine).length;
                
                if (notesAboveCenter > notesBelowCenter) {
                    stemDirection = 'up'; // Majority above center
                } else {
                    stemDirection = 'down';   // Majority below center
                }
            } else if (avgPosition >= 31 && avgPosition <= 39) {
                // Bass clef region
                const notesAboveCenter = notePositions.filter(pos => pos < bassCenterLine).length;
                const notesBelowCenter = notePositions.filter(pos => pos > bassCenterLine).length;
                
                if (notesAboveCenter > notesBelowCenter) {
                    stemDirection = 'up'; // Majority above center
                } else {
                    stemDirection = 'down';   // Majority below center
                }
            } else if (avgPosition >= 16 && avgPosition <= 34) {
                // Middle region - stem direction based on clef
                if (chordData.clef === 'treble') {
                    stemDirection = 'down'; // Treble in middle: stem from above (down)
                } else {
                    stemDirection = 'up';   // Bass in middle: stem from below (up)
                }
            
            
            } else if (avgPosition <= 10) {
                // Above treble staff
                stemDirection = 'up';
            } else if (avgPosition >= 30) {
                // Below bass staff
                stemDirection = 'down';
            }
            // Apply stem direction
            if (stemDirection === 'down') {
                stem.classList.add('stem-down');
                const highestNoteOffset = (highestPos - avgPosition) * pixelsPerPosition;
                stem.style.top = (highestNoteOffset - 25) + 'px'; // Start from highest note
                stem.style.left = '1px';  // LEFT side for stem down
                stem.style.height = Math.max(35, (lowestPos - highestPos) * pixelsPerPosition + 35) + 'px';
            } else {
                stem.classList.add('stem-up');
                const lowestNoteOffset = (lowestPos - avgPosition) * pixelsPerPosition;
                const highestNoteOffset = (highestPos - avgPosition) * pixelsPerPosition;
                
                stem.style.top = (highestNoteOffset + 3) + 'px'; // Start below lowest note
                stem.style.right = '2px';
                stem.style.height = (lowestNoteOffset - highestNoteOffset + 35) + 'px'; // Full span + extension
            }

            chordContainer.appendChild(stem);
            
            // Sort notes by pitch (lowest to highest) for sequential guessing
            const sortedNotes = [...chordData.notes].sort((a, b) => {
                return NOTE_POSITIONS[b.fullKey] - NOTE_POSITIONS[a.fullKey]; // Higher position = lower pitch
            });

            // Store chord data
            chordContainer.noteData = {
                isChord: true,
                chordName: chordData.chordName,
                notes: sortedNotes,  // Use sorted notes
                area: chordData.area,
                guessed: false,
                correctNotes: new Set(),
                totalGuesses: 0,
                maxGuesses: sortedNotes.length,
                currentNoteIndex: 0  // Track which note we're currently expecting
            };

            // Apply initial visual state - only lowest note is black, others are gray
            // Apply initial visual state - ALL notes start gray, will be activated when chord becomes active
            chordContainer.querySelectorAll('.chord-note').forEach((noteElement, index) => {
                const noteHead = noteElement.querySelector('.note-head');
                //noteHead.style.opacity = '0.85';
                noteHead.style.backgroundColor = '#777';
            });
                        
            return chordContainer;
        }

        function updateChordVisualStates() {
            // Reset ALL chord notes to gray first
            document.querySelectorAll('.chord-note .note-head').forEach(noteHead => {
                if (!noteHead.classList.contains('correct') && !noteHead.classList.contains('incorrect')) {
                    //noteHead.style.opacity = '0.85';
                    noteHead.style.backgroundColor = '#777';
                }
            });
            
            // For moving notes: activate current target note of the first unguessed chord
            if (gameState.gameMode === 'moving' && gameState.activeNotes) {
                const activeChord = gameState.activeNotes.find(note => 
                    note.noteData.isChord && !note.noteData.guessed
                );
                if (activeChord) {
                    const currentIndex = activeChord.noteData.currentNoteIndex;
                    const noteElements = activeChord.querySelectorAll('.chord-note');
                    if (noteElements[currentIndex]) {
                        const noteHead = noteElements[currentIndex].querySelector('.note-head');
                        noteHead.style.opacity = '1';
                        noteHead.style.backgroundColor = '';
                    }
                }
            }
            
            // For still notes: activate current target note of the current chord
            if (gameState.gameMode === 'still' && gameState.stillNotes && gameState.currentStillNoteIndex < gameState.stillNotes.length) {
                const currentElement = gameState.stillNotes[gameState.currentStillNoteIndex];
                if (currentElement && currentElement.noteData.isChord) {
                    const currentIndex = currentElement.noteData.currentNoteIndex;
                    const noteElements = currentElement.querySelectorAll('.chord-note');
                    if (noteElements[currentIndex]) {
                        const noteHead = noteElements[currentIndex].querySelector('.note-head');
                        noteHead.style.opacity = '1';
                        noteHead.style.backgroundColor = '';
                    }
                }
            }
        }

        function needsLedgerLines(notePosition) {
            // Above treble staff (positions 1-5)
            if (notePosition <= 10) return { type: 'above-treble', notePosition: notePosition };
            
            // Below treble staff, above bass staff (positions 20-30) 
            if (notePosition >= 20 && notePosition <= 30) return { type: 'middle', notePosition: notePosition };
            
            // Below bass staff (positions 40-48)
            if (notePosition >= 40) return { type: 'below-bass', notePosition: notePosition };
            
            return null;
        }

        function addLedgerLines(noteElement, ledgerInfo) {
            if (!ledgerInfo) return;
            
            const notePosition = ledgerInfo.notePosition;
            
            // Check stem direction
            const stem = noteElement.querySelector('.note-stem');
            const isStemDown = stem.classList.contains('stem-down');
            

            
            // Calculate which LINE positions need ledger lines
            let ledgerLinePositions = [];
            
            if (ledgerInfo.type === 'above-treble') {
                // For notes above treble staff (positions 1-10)
                if (notePosition % 2 === 1) {
                    for (let pos = notePosition; pos <= 9; pos += 2) {
                        ledgerLinePositions.push(pos);
                    }
                } else {
                    for (let pos = notePosition + 1; pos <= 9; pos += 2) {
                        ledgerLinePositions.push(pos);
                    }
                }
            } else if (ledgerInfo.type === 'below-bass') {
                // For notes below bass staff (positions 40+)
                if (notePosition % 2 === 1) {
                    for (let pos = 41; pos <= notePosition; pos += 2) {
                        ledgerLinePositions.push(pos);
                    }
                } else {
                    for (let pos = 41; pos <= notePosition - 1; pos += 2) {
                        ledgerLinePositions.push(pos);
                    }
                }
            } else if (ledgerInfo.type === 'middle') {
                // Use stem direction to determine treble vs bass
                if (isStemDown) {
                    // Stem down = middle-bass, connect down to bass staff
                    if (notePosition % 2 === 1) {
                        for (let pos = notePosition; pos <= 29; pos += 2) {
                            ledgerLinePositions.push(pos);
                        }
                    } else {
                        for (let pos = notePosition + 1; pos <= 29; pos += 2) {
                            ledgerLinePositions.push(pos);
                        }
                    }
                } else {
                    // Stem up = middle-treble, connect up to treble staff
                    if (notePosition % 2 === 1) {
                        for (let pos = notePosition; pos >= 21; pos -= 2) {
                            ledgerLinePositions.push(pos);
                        }
                    } else {
                        for (let pos = notePosition - 1; pos >= 21; pos -= 2) {
                            ledgerLinePositions.push(pos);
                        }
                    }
                }
            }
            
            // Draw all ledger lines
            const staffHeight = 280;
            const pixelsPerPosition = staffHeight / 48;
            
            ledgerLinePositions.forEach(pos => {
                const offsetPositions = pos - notePosition;
                const offsetPixels = offsetPositions * pixelsPerPosition;
                
                const ledgerLine = document.createElement('div');
                ledgerLine.style.position = 'absolute';
                ledgerLine.style.width = '24px';
                ledgerLine.style.height = '2px';
                ledgerLine.style.background = '#333';
                ledgerLine.style.left = '-4px';
                ledgerLine.style.top = `calc(50% + ${offsetPixels}px)`;
                ledgerLine.style.transform = 'translateY(-50%)';
                ledgerLine.style.zIndex = '8';
                noteElement.appendChild(ledgerLine);
            });
            
        }

        function showNote() {
            if (!gameState.isPlaying || gameState.gameMode !== 'moving') return;

            // Find the showNote() function and add this debug right before the noteData generation:

            const noteData = gameState.chordMode ? generateChord() : 
                            (gameState.noteMode === 'scales' ? generateScaleNote() : generateNote());

            const movingNote = createNoteElement(noteData, false);
            movingNote.style.right = '-30px'; // Start outside the frame
            if (noteData.isChord) {
                movingNote.style.animationDuration = '12000ms'; // Slower animation for chords
            } else {
                movingNote.style.animationDuration = '8000ms';  // Normal speed for single notes
            }

            const isLandscapeChordMode = document.body.classList.contains('landscape-mode-active');
            const container = isLandscapeChordMode ? 
                document.querySelector('.staff-inner') || document.querySelector('.staff-area') :
                document.querySelector('.staff-area');

            container.appendChild(movingNote);

            setTimeout(() => {
                movingNote.classList.add('animate');
            }, 100);
            
            if (!gameState.activeNotes) gameState.activeNotes = [];
            gameState.activeNotes.push(movingNote);
            // If it's a chord, activate the first note immediately
            // Update chord visual states
            if (noteData.isChord) {
                setTimeout(updateChordVisualStates, 50);
            }
            
            const timeout = noteData.isChord ? 12000 : 8000;
            setTimeout(() => {
                if (!movingNote.noteData.guessed) {
                    handleWrongAnswer();
                }
                movingNote.remove();
                gameState.activeNotes = gameState.activeNotes.filter(n => n !== movingNote);
            }, timeout);
            
            const noteCount = DIFFICULTY_SETTINGS[gameState.difficulty].noteCount;
            const interval = 8000 / noteCount;
            setTimeout(() => {
                if (gameState.isPlaying && gameState.gameMode === 'moving') showNote();
            }, interval);
        }

        function createStillNotes() {
            const container = document.getElementById('stillNotesContainer');
            container.innerHTML = '';
            container.classList.add('active');
            
            gameState.stillNotes = [];
            gameState.currentStillNoteIndex = 0;
            
            const noteCount = gameState.noteMode === 'scales' ? 7 : (gameState.chordMode ? 6 : 8);
            const containerWidth = container.offsetWidth || 300;
            const spacing = containerWidth / (noteCount + 1);
            
            for (let i = 0; i < noteCount; i++) {
                const noteData = gameState.chordMode ? generateChord() : 
                    (gameState.noteMode === 'scales' ? generateScaleNote() : generateNote());
                const stillNote = createNoteElement(noteData, true);
                stillNote.style.left = `${spacing * (i + 1) - 9}px`; // Center the note
                stillNote.style.position = 'absolute';
                
                // Add index for tracking
                stillNote.noteIndex = i;
                
                container.appendChild(stillNote);
                gameState.stillNotes.push(stillNote);
            }
            
            // Highlight first note/chord
            if (gameState.stillNotes.length > 0) {
                const firstElement = gameState.stillNotes[0];
                if (firstElement.noteData.isChord) {
                    // Make first chord stem blue
                    const chordStem = firstElement.querySelector('.note-stem');
                    if (chordStem) {
                        chordStem.style.backgroundColor = 'blue';
                    }
                } else {
                    firstElement.style.border = '2px solid blue';
                    firstElement.style.borderRadius = '50%';
                }
            }

            // Apply initial visual states
            updateChordVisualStates();


        }

        function getScaleNote(baseLetter, selectedScale) {
            const scaleAccidentals = SCALE_DEFINITIONS[selectedScale] || [];
            
            for (let accidental of scaleAccidentals) {
                const accidentalLetter = accidental.charAt(0);
                if (accidentalLetter === baseLetter) {
                    return accidental;
                }
            }
            
            return baseLetter;
        }

        function getEnharmonicEquivalents(note) {
            const enharmonics = {
                'C#': ['C#', 'Db'], 'Db': ['C#', 'Db'],
                'D#': ['D#', 'Eb'], 'Eb': ['D#', 'Eb'],
                'F#': ['F#', 'Gb'], 'Gb': ['F#', 'Gb'],
                'G#': ['G#', 'Ab'], 'Ab': ['G#', 'Ab'],
                'A#': ['A#', 'Bb'], 'Bb': ['A#', 'Bb']
            };
            
            return enharmonics[note] || [note];
        }

        function handleCorrectAnswer() {
            clearWrongNoteDisplay(); // ADD THIS LINE
            gameState.score++;
            gameState.consecutiveMisses = 0;
            
            // Track reaction time
            const currentTime = Date.now();
            const reactionTime = currentTime - gameState.lastNoteTime;
            gameState.reactionTimes.push(reactionTime);
            gameState.lastNoteTime = currentTime;
            
            // Track area performance
            let currentNote = null;
            if (gameState.gameMode === 'moving') {
                currentNote = gameState.activeNotes.find(n => n.noteData.guessed);
            } else {
                currentNote = gameState.stillNotes[gameState.currentStillNoteIndex - 1];
            }

            if (currentNote && currentNote.noteData && currentNote.noteData.area) {
                gameState.areaStats[currentNote.noteData.area].correct++;
                gameState.areaStats[currentNote.noteData.area].total++;
            }
            

            if (gameState.score >= TARGET_SCORE) {
                winGame();
                return;
            }

            updateDisplay();
            
        }

        function handleWrongAnswer(pressedNote = null, expectedNote = null) {
            gameState.consecutiveMisses++;
            gameState.totalMisses++;
            
            // Show wrong note display if notes are provided
            if (pressedNote && expectedNote) {
                showWrongNote(pressedNote, expectedNote);
            }
            
            // Track area performance for wrong answers
            let currentNote = null;
            if (gameState.gameMode === 'moving') {
                currentNote = gameState.activeNotes.find(n => n.noteData.guessed);
            } else {
                currentNote = gameState.stillNotes[gameState.currentStillNoteIndex];
            }

            if (currentNote && currentNote.noteData && currentNote.noteData.area) {
                gameState.areaStats[currentNote.noteData.area].total++;
            }
            
            // Reset reaction time tracking
            gameState.lastNoteTime = Date.now();
            
            // Visual feedback - only if game is still running
            if (gameState.isPlaying) {
                document.body.classList.add('screen-flicker');
                setTimeout(() => {
                    if (gameState.isPlaying) {
                        document.body.classList.remove('screen-flicker');
                    }
                }, 500);
            }

            if (gameState.consecutiveMisses >= 3) {
                gameOver();
                return;
            }

            updateDisplay();
        }


        function handleMovingNoteGuess(pressedNote) {
            if (!gameState.activeNotes || gameState.activeNotes.length === 0) return;

            let targetNote = null;
            for (let note of gameState.activeNotes) {
                if (!note.noteData.guessed) {
                    targetNote = note;
                    break;
                }
            }

            if (!targetNote) return;

            // FIX #1 applied here too: Play sound from the logic handler.
            let targetOctave;
            if (targetNote.noteData.isChord) {
                const currentIndex = targetNote.noteData.currentNoteIndex;
                const currentTargetNote = targetNote.noteData.notes[currentIndex];
                targetOctave = currentTargetNote.octave;
            } else {
                targetOctave = targetNote.noteData.octave;
            }
            playPianoSound(pressedNote, targetOctave);

            // HANDLE CHORDS
            if (targetNote.noteData.isChord) {
                const currentIndex = targetNote.noteData.currentNoteIndex;
                const currentTargetNote = targetNote.noteData.notes[currentIndex];
                const expectedNote = currentTargetNote.note;
                const expectedNotes = getEnharmonicEquivalents(expectedNote);
                const noteElements = targetNote.querySelectorAll('.chord-note');

                targetNote.noteData.totalGuesses++;

                if (expectedNotes.includes(pressedNote)) {
                    targetNote.noteData.correctNotes.add(expectedNote);

                    if (noteElements[currentIndex]) {
                        const noteHead = noteElements[currentIndex].querySelector('.note-head');
                        noteHead.classList.add('correct');
                        noteHead.style.opacity = '1';
                        noteHead.style.backgroundColor = '';
                    }

                    targetNote.noteData.currentNoteIndex++;
                    updateChordVisualStates();

                    if (targetNote.noteData.currentNoteIndex < targetNote.noteData.notes.length) {
                        const nextIndex = targetNote.noteData.currentNoteIndex;
                        if (noteElements[nextIndex]) {
                            const nextNoteHead = noteElements[nextIndex].querySelector('.note-head');
                            nextNoteHead.style.opacity = '1';
                            nextNoteHead.style.backgroundColor = '';
                        }
                    }
                } else {
                    if (noteElements[currentIndex]) {
                        const noteHead = noteElements[currentIndex].querySelector('.note-head');
                        noteHead.classList.add('incorrect');
                        noteHead.style.opacity = '1';
                    }

                    targetNote.noteData.currentNoteIndex++;

                    if (targetNote.noteData.currentNoteIndex < targetNote.noteData.notes.length) {
                        const nextIndex = targetNote.noteData.currentNoteIndex;
                        if (noteElements[nextIndex]) {
                            const nextNoteHead = noteElements[nextIndex].querySelector('.note-head');
                            nextNoteHead.style.opacity = '1';
                            nextNoteHead.style.backgroundColor = '';
                        }
                    }
                }

                if (targetNote.noteData.currentNoteIndex >= targetNote.noteData.notes.length) {
                    targetNote.noteData.guessed = true;

                    if (targetNote.noteData.correctNotes.size === targetNote.noteData.notes.length) {
                        handleCorrectAnswer();
                    } else {
                        handleWrongAnswer();
                    }
                }

                return;
            }

            // HANDLE SINGLE NOTES
            let expectedNote = targetNote.noteData.note;

            if (targetNote.noteData.accidental) {
                switch (targetNote.noteData.accidental) {
                    case 'sharp': expectedNote += '#'; break;
                    case 'flat': expectedNote += 'b'; break;
                    case 'natural': expectedNote = targetNote.noteData.note; break;
                }
            } else {
                expectedNote = targetNote.noteData.scaleNote;
            }

            const expectedNotes = getEnharmonicEquivalents(expectedNote);
            if (expectedNotes.includes(pressedNote)) {
                targetNote.querySelector('.note-head').classList.add('correct');
                targetNote.noteData.guessed = true;
                handleCorrectAnswer();
                if (gameState.noteMode === 'scales' && gameState.currentScale && 
                    gameState.currentScale.currentIndex === gameState.currentScale.notes.length) {
                    // Scale completed
                }

            } else {
                targetNote.querySelector('.note-head').classList.add('incorrect');
                targetNote.noteData.guessed = true;
                handleWrongAnswer(pressedNote, expectedNotes[0]);
            }
        }

        function handleStillNoteGuess(pressedNote) {
            if (!gameState.stillNotes || gameState.currentStillNoteIndex >= gameState.stillNotes.length) return;

            const currentNote = gameState.stillNotes[gameState.currentStillNoteIndex];
            if (!currentNote || currentNote.noteData.guessed) return;

            // FIX #1: Determine the correct octave and play the sound from here.
            let targetOctave;
            if (currentNote.noteData.isChord) {
                const currentIndex = currentNote.noteData.currentNoteIndex;
                const currentTargetNote = currentNote.noteData.notes[currentIndex];
                targetOctave = currentTargetNote.octave;
            } else {
                targetOctave = currentNote.noteData.octave;
            }
            playPianoSound(pressedNote, targetOctave);

            // HANDLE CHORDS - Sequential note guessing
            if (currentNote.noteData.isChord) {
                const currentIndex = currentNote.noteData.currentNoteIndex;
                const currentTargetNote = currentNote.noteData.notes[currentIndex];
                const expectedNote = currentTargetNote.note;
                const expectedNotes = getEnharmonicEquivalents(expectedNote);
                const noteElements = currentNote.querySelectorAll('.chord-note');

                currentNote.noteData.totalGuesses++;

                if (expectedNotes.includes(pressedNote)) {
                    // Correct note!
                    currentNote.noteData.correctNotes.add(expectedNote);

                    if (noteElements[currentIndex]) {
                        const noteHead = noteElements[currentIndex].querySelector('.note-head');
                        noteHead.classList.add('correct');
                        noteHead.style.opacity = '1';
                        noteHead.style.backgroundColor = '';
                    }

                    currentNote.noteData.currentNoteIndex++;
                    updateChordVisualStates();

                    if (currentNote.noteData.currentNoteIndex < currentNote.noteData.notes.length) {
                        const nextIndex = currentNote.noteData.currentNoteIndex;
                        if (noteElements[nextIndex]) {
                            const nextNoteHead = noteElements[nextIndex].querySelector('.note-head');
                            nextNoteHead.style.opacity = '1';
                            nextNoteHead.style.backgroundColor = '';
                        }
                    }
                } else {
                    // Wrong note
                    if (noteElements[currentIndex]) {
                        const noteHead = noteElements[currentIndex].querySelector('.note-head');
                        noteHead.classList.add('incorrect');
                        noteHead.style.opacity = '1';
                    }

                    currentNote.noteData.currentNoteIndex++;

                    if (currentNote.noteData.currentNoteIndex < currentNote.noteData.notes.length) {
                        const nextIndex = currentNote.noteData.currentNoteIndex;
                        if (noteElements[nextIndex]) {
                            const nextNoteHead = noteElements[nextIndex].querySelector('.note-head');
                            nextNoteHead.style.opacity = '1';
                            nextNoteHead.style.backgroundColor = '';
                        }
                    }
                }

                if (currentNote.noteData.currentNoteIndex >= currentNote.noteData.notes.length) {
                    currentNote.noteData.guessed = true;

                    const chordStem = currentNote.querySelector('.note-stem');
                    if (chordStem) {
                        chordStem.style.backgroundColor = '';
                    }

                    if (currentNote.noteData.correctNotes.size === currentNote.noteData.notes.length) {
                        handleCorrectAnswer();
                    } else {
                        handleWrongAnswer();
                    }

                    gameState.currentStillNoteIndex++;
                    updateChordVisualStates();

                    if (gameState.currentStillNoteIndex < gameState.stillNotes.length) {
                        const nextElement = gameState.stillNotes[gameState.currentStillNoteIndex];

                        if (nextElement.noteData.isChord) {
                            document.getElementById('currentScaleDisplay').textContent = `Chord: ${nextElement.noteData.chordName}`;
                            document.getElementById('miniStaffDisplay').style.display = 'none';

                            const nextChordStem = nextElement.querySelector('.note-stem');
                            if (nextChordStem) {
                                nextChordStem.style.backgroundColor = 'blue';
                            }
                        }

                        if (!nextElement.noteData.isChord) {
                            nextElement.style.border = '2px solid blue';
                            nextElement.style.borderRadius = '50%';
                        }
                    } else {
                        setTimeout(() => {
                            if (gameState.isPlaying) createStillNotes();
                        }, 1000);
                    }
                }

                return;
            }

            // HANDLE SINGLE NOTES
            let expectedNote = currentNote.noteData.note;
            if (currentNote.noteData.accidental) {
                switch (currentNote.noteData.accidental) {
                    case 'sharp': expectedNote += '#'; break;
                    case 'flat': expectedNote += 'b'; break;
                    case 'natural': expectedNote = currentNote.noteData.note; break;
                }
            } else {
                expectedNote = currentNote.noteData.scaleNote;
            }

            const expectedNotes = getEnharmonicEquivalents(expectedNote);
            if (expectedNotes.includes(pressedNote)) {
                currentNote.querySelector('.note-head').classList.add('correct');
                currentNote.noteData.guessed = true;
                currentNote.style.border = 'none';
                handleCorrectAnswer();

                // FIX #2: Increment the index on a correct answer to move to the next note.
                gameState.currentStillNoteIndex++;

                if (gameState.currentStillNoteIndex < gameState.stillNotes.length) {
                    const nextElement = gameState.stillNotes[gameState.currentStillNoteIndex];
                    if (!nextElement.noteData.isChord) {
                        nextElement.style.border = '2px solid blue';
                        nextElement.style.borderRadius = '50%';
                    }
                } else {
                    setTimeout(() => {
                        if (gameState.isPlaying) createStillNotes();
                    }, 1000);
                }
            } else {
                currentNote.querySelector('.note-head').classList.add('incorrect');
                currentNote.noteData.guessed = true;
                currentNote.style.border = 'none';
                handleWrongAnswer(pressedNote, expectedNotes[0]);

                if (gameState.isPlaying) {
                    gameState.currentStillNoteIndex++;
                    if (gameState.currentStillNoteIndex < gameState.stillNotes.length) {
                        const nextElement = gameState.stillNotes[gameState.currentStillNoteIndex];
                        if (!nextElement.noteData.isChord) {
                            nextElement.style.border = '2px solid blue';
                            nextElement.style.borderRadius = '50%';
                        }
                    } else {
                        setTimeout(() => {
                            if (gameState.isPlaying) createStillNotes();
                        }, 1000);
                    }
                }
            }
        }

        function unlockComposer() {
            const availableComposers = COMPOSERS.filter(c => !gameState.composersCollected.includes(c));
            if (availableComposers.length === 0) return;

            const randomComposer = availableComposers[Math.floor(Math.random() * availableComposers.length)];
            gameState.composersCollected.push(randomComposer);

            // Create falling composer animation
            const staffArea = document.querySelector('.staff-area');
            const fallingComposer = document.createElement('div');
            fallingComposer.className = 'falling-composer';
            fallingComposer.textContent = randomComposer;
            fallingComposer.style.left = Math.random() * (staffArea.offsetWidth - 50) + 'px';
            
            staffArea.appendChild(fallingComposer);
            
            // Update composer portrait
            const portraitIndex = COMPOSERS.indexOf(randomComposer);
            const portrait = document.getElementById(`composer-${portraitIndex}`);
            if (portrait) {
                setTimeout(() => {
                    portrait.classList.add('collected');
                }, 1000);
            }
            
            // Remove falling element
            setTimeout(() => {
                fallingComposer.remove();
            }, 2000);

            updateDisplay();
        }

        function gameOver() {
            gameState.isPlaying = false;
            
            // Clear all existing timeouts to stop note generation
            for (let i = 1; i < 99999; i++) {
                window.clearTimeout(i);
            }
            
            // Remove all active notes from the screen
            const existingNotes = document.querySelectorAll('.moving-note');
            existingNotes.forEach(note => note.remove());
            
            // Clear active notes array
            gameState.activeNotes = [];
            
            // Clear still notes
            const stillContainer = document.getElementById('stillNotesContainer');
            stillContainer.classList.remove('active');
            stillContainer.innerHTML = '';
            gameState.stillNotes = [];
            
            // Stop any screen flickering
            document.body.classList.remove('screen-flicker');
            
            // Calculate statistics
            const totalNotes = gameState.score + gameState.totalMisses;
            const accuracy = totalNotes > 0 ? Math.round((gameState.score / totalNotes) * 100) : 0;
            const avgReactionTime = gameState.reactionTimes.length > 0 ? 
                Math.round(gameState.reactionTimes.reduce((a, b) => a + b, 0) / gameState.reactionTimes.length) : 0;

            // Calculate final score: (accuracy% * notes_collected / target_notes) * 100
            const finalScore = Math.round((accuracy / 100) * (gameState.score / TARGET_SCORE) * 100);

            // Find worst performing area
            let worstArea = 'None';
            let worstAccuracy = 100;
            Object.entries(gameState.areaStats).forEach(([area, stats]) => {
                if (stats.total > 0) {
                    const areaAccuracy = (stats.correct / stats.total) * 100;
                    if (areaAccuracy < worstAccuracy) {
                        worstAccuracy = areaAccuracy;
                        worstArea = area;
                    }
                }
            });

            const areaNames = {
                aboveBelow: 'Above/Below Staff',
                between: 'Between Staves',
                treble: 'Treble Clef',
                bass: 'Bass Clef'
            };
            
            document.getElementById('gameOver').innerHTML = `
                <div>Game Over!</div>
                <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #FFD700;">Final Score: ${finalScore}%</div>
                </div>
                <div style="margin: 5px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 14px; text-align: left;">
                    <div style="font-weight: bold; margin-bottom: 8px;">Game Settings:</div>
                    ${getGameSettingsSummary()}
                </div>
 

                <div style="margin: 20px 0; font-size: 16px;">
                    <div><strong>Notes Hit:</strong> ${gameState.score}/${TARGET_SCORE}</div>
                    <div><strong>Accuracy:</strong> ${accuracy}%</div>
                    <div><strong>Avg Reaction Time:</strong> ${avgReactionTime}ms</div>
                    <div><strong>Area for Improvement:</strong> ${areaNames[worstArea] || worstArea}</div>
                </div>
                <button class="play-again-btn" onclick="showStartScreen()">Back to game</button>
            `;
            
            document.getElementById('gameOver').style.display = 'flex';
        }

        function winGame() {
            gameState.isPlaying = false;
            
            // Clear all existing timeouts to stop note generation
            for (let i = 1; i < 99999; i++) {
                window.clearTimeout(i);
            }
            
            // Remove all active notes from the screen
            const existingNotes = document.querySelectorAll('.moving-note');
            existingNotes.forEach(note => note.remove());
            
            // Clear active notes array
            gameState.activeNotes = [];
            
            // Clear still notes
            const stillContainer = document.getElementById('stillNotesContainer');
            stillContainer.classList.remove('active');
            stillContainer.innerHTML = '';
            gameState.stillNotes = [];
            
            // Stop any screen flickering
            document.body.classList.remove('screen-flicker');
            
            // Calculate statistics
            const totalNotes = gameState.score + gameState.totalMisses;
            const accuracy = totalNotes > 0 ? Math.round((gameState.score / totalNotes) * 100) : 0;
            const avgReactionTime = gameState.reactionTimes.length > 0 ? 
                Math.round(gameState.reactionTimes.reduce((a, b) => a + b, 0) / gameState.reactionTimes.length) : 0;

            // Calculate final score: (accuracy% * notes_collected / target_notes) * 100
            const finalScore = Math.round((accuracy / 100) * (gameState.score / TARGET_SCORE) * 100);

            // Find worst performing area
            let worstArea = 'None';
            let worstAccuracy = 100;
            Object.entries(gameState.areaStats).forEach(([area, stats]) => {
                if (stats.total > 0) {
                    const areaAccuracy = (stats.correct / stats.total) * 100;
                    if (areaAccuracy < worstAccuracy) {
                        worstAccuracy = areaAccuracy;
                        worstArea = area;
                    }
                }
            });

            const areaNames = {
                aboveBelow: 'Above/Below Staff',
                between: 'Between Staves',
                treble: 'Treble Clef',
                bass: 'Bass Clef'
            };
            
            document.getElementById('gameOver').innerHTML = `
                <div>🎉 Congratulations! 🎉</div>
                <div>You Won!</div>
                <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #FFD700;">Final Score: ${finalScore}%</div>
                </div>
                <div style="margin: 5px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 14px; text-align: left;">
                    <div style="font-weight: bold; margin-bottom: 8px;">Game Settings:</div>
                    ${getGameSettingsSummary()}
                </div>
                <div style="margin: 20px 0; font-size: 16px;">
                    <div><strong>Notes Hit:</strong> ${gameState.score}/${TARGET_SCORE}</div>
                    <div><strong>Accuracy:</strong> ${accuracy}%</div>
                    <div><strong>Avg Reaction Time:</strong> ${avgReactionTime}ms</div>
                    <div><strong>Area for Improvement:</strong> ${areaNames[worstArea] || worstArea}</div>
                </div>

                <button class="play-again-btn" onclick="showStartScreen()">Back to game</button>
            `;
            
            document.getElementById('gameOver').style.display = 'flex';
            
        }

        function startNewGame() {
            // Add this at the beginning of startNewGame()
            if (Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    // Trigger a silent note to preload samples
                    piano.triggerAttackRelease("C4", "1n", "+0", 0);
                });
            }
            document.getElementById('endGameBtn').style.display = 'inline-block';
            document.getElementById('notesToggle').disabled = true;
            document.getElementById('scalesToggle').disabled = true;
            document.getElementById('chordsToggle').disabled = true;
            document.getElementById('gameModeToggle').disabled = true;
            document.getElementById('stillToggle').disabled = true;

            ClefSwitchingModule.disableButton();

            // Store the current selectedRegions before resetting
            const currentSelectedRegions = gameState.selectedRegions || ['above', 'treble', 'middle', 'bass', 'below'];
            const currentChordMode = gameState.chordMode || false;  // ADD THIS LINE
            // ADD THIS LINE:
            const clefButton = document.getElementById('clefToggleButton');
            if (clefButton) {
                clefButton.style.pointerEvents = 'none';
                clefButton.style.opacity = '0.5';
            }

            gameState = {
                score: 0,
                consecutiveMisses: 0,
                currentNote: null,
                currentNoteOctave: 4,
                selectedScale: document.getElementById('scale').value,
                difficulty: document.getElementById('difficultySelect').value,
                gameMode: gameState.gameMode, // Use existing state
                selectedRegions: currentSelectedRegions,
                noteMode: gameState.noteMode, // Use existing state
                currentScale: {
                    notes: [],
                    currentIndex: 0,
                    clef: null,
                    scaleName: null
                },
                isPlaying: true,
                waitingForAnswer: false,
                noteStartTime: 0,
                activeNotes: [],
                stillNotes: [],
                currentStillNoteIndex: 0,
                // New tracking variables
                totalMisses: 0,
                reactionTimes: [],
                lastNoteTime: Date.now(),
                areaStats: {
                    aboveBelow: { correct: 0, total: 0 },
                    between: { correct: 0, total: 0 },
                    treble: { correct: 0, total: 0 },
                    bass: { correct: 0, total: 0 }
                },
                chordMode: currentChordMode,
                currentChord: null
            };

            // Disable game configuration buttons during play
            document.getElementById('scale').disabled = true;
            document.getElementById('difficultySelect').disabled = true;
            // document.getElementById('gameMode').disabled = true;
            document.getElementById('regionSelect').disabled = true; // ADD THIS LINE
            // Update difficulty display based on game mode
            if (gameState.gameMode === 'still') {
                document.getElementById('difficulty').textContent = 'Still';
            } else {
                document.getElementById('difficulty').textContent = 
                    gameState.difficulty.charAt(0).toUpperCase() + gameState.difficulty.slice(1);
            }


            // Handle random scale selection
            if (gameState.selectedScale === 'random') {
                const availableScales = ['C', 'G', 'D', 'A', 'E', 'F', 'Bb', 'Am', 'Em', 'Bm', 'Dm', 'Gm', 'Cm'];
                gameState.selectedScale = availableScales[Math.floor(Math.random() * availableScales.length)];
            }

            // Update key signature display with the actual scale
            displayKeySignature(gameState.selectedScale);
            updateScaleDisplay();
            document.getElementById('scaleDisplay').style.display = 'block';


            document.getElementById('gameStartOverlay').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            
            // Clear any existing notes
            const existingNotes = document.querySelectorAll('.moving-note');
            existingNotes.forEach(note => note.remove());
            
            updateDisplay();
            
            // Start appropriate game mode
            if (gameState.gameMode === 'moving') {
                setTimeout(showNote, 1000);
            } else {
                setTimeout(createStillNotes, 1000);
            }

            // Show/hide scale display based on mode
            // Show/hide scale display based on mode
            // Hide scale display initially - it will show when first scale is generated
            document.getElementById('scaleInfoContainer').style.display = 'none';
        }

        function updateDisplay() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('targetScore').textContent = TARGET_SCORE;
            document.getElementById('lives').textContent = gameState.consecutiveMisses;
            
            // Update progress bar
            const progressPercentage = (gameState.score / TARGET_SCORE) * 100;
            document.getElementById('progressBar').style.width = progressPercentage + '%';
        }

        function updateScaleDisplay() {
            const scaleNames = {
                'C': 'C Major', 'G': 'G Major', 'D': 'D Major', 'A': 'A Major', 'E': 'E Major',
                'F': 'F Major', 'B': 'B Major', 'Am': 'A Minor', 'Em': 'E Minor', 
                'Bm': 'B Minor', 'Dm': 'D Minor', 'Gm': 'G Minor', 'Cm': 'C Minor'
            };
            
            const displayName = scaleNames[gameState.selectedScale] || gameState.selectedScale;
            document.getElementById('scaleDisplay').textContent = `Scale: ${displayName}`;
        }

        function generateChord() {
            const chordKeys = Object.keys(CHORDS);
            const randomChord = chordKeys[Math.floor(Math.random() * chordKeys.length)];
            const chordNotes = CHORDS[randomChord];

            const validPositions = findValidChordPositions(chordNotes);
                     
            if (validPositions.length === 0) {
                
                return generateNote();
            }
            
            const regionFilteredPositions = validPositions.filter(position => {

                const notesInRegion = position.notes.filter(noteInfo => {
                    const notePosition = NOTE_POSITIONS[noteInfo.fullKey];
                    const inRegion = isNoteInSelectedRegions(notePosition);

                    return inRegion;
                });
                
                return notesInRegion.length > 0;
            });
                        
            if (regionFilteredPositions.length === 0) {
                
                return generateNote(); // Fallback
            }
            
            const selectedPosition = regionFilteredPositions[Math.floor(Math.random() * regionFilteredPositions.length)];
            // Show chord name only (no mini staff)
            document.getElementById('currentScaleDisplay').textContent = `Chord: ${randomChord}`;
            document.getElementById('scaleInfoContainer').style.display = 'block';
            document.getElementById('currentScaleDisplay').style.display = 'block';

            // Hide the mini staff for chords
            document.getElementById('miniStaffDisplay').style.display = 'none';

            return {
                chordName: randomChord,
                notes: selectedPosition.notes,
                clef: selectedPosition.clef,
                isChord: true,
                area: selectedPosition.clef
            };
        }

        function isNoteInSelectedRegions(position) {
            const allowedSections = gameState.selectedRegions;
            
            return (allowedSections.includes('above') && position <= 10) ||
                (allowedSections.includes('treble') && position >= 11 && position <= 19) ||
                (allowedSections.includes('middle') && position >= 20 && position <= 30) ||
                (allowedSections.includes('bass') && position >= 31 && position <= 39) ||
                (allowedSections.includes('below') && position >= 40);
        }


        function showWrongNote(pressedNote, correctNote) {
            document.getElementById('scaleDisplay').style.display = 'none';
            document.getElementById('wrongNoteDisplay').style.display = 'flex';
            document.getElementById('wrongNote').textContent = pressedNote;
            document.getElementById('correctNote').textContent = correctNote;
        }

        function clearWrongNoteDisplay() {
            document.getElementById('wrongNoteDisplay').style.display = 'none';
        }

        function displayMiniKeySignature(selectedScale) {
            // Clear old accidentals from both staff containers
            const trebleStaff = document.getElementById('miniTrebleStaff');
            const bassStaff = document.getElementById('miniBassStaff');
            
            // Remove all existing accidental elements
            trebleStaff.querySelectorAll('div').forEach(div => {
                if (div.textContent === '♯' || div.textContent === '♭') {
                    div.remove();
                }
            });
            
            bassStaff.querySelectorAll('div').forEach(div => {
                if (div.textContent === '♯' || div.textContent === '♭') {
                    div.remove();
                }
            });
            
            const scaleAccidentals = SCALE_DEFINITIONS[selectedScale] || [];
            
            // Convert main game positions to mini staff positions
            // Main game: position 18 (F4) maps to treble line 4 (40px)
            // Main game: position 15 (B4) maps to treble line 3 (20px) 
            // Main game: position 12 (E5) maps to treble space 2 (35px)
            // etc.
            
            const miniAccidentalPositions = {
                'F#': [
                    { clef: 'treble', top: 0, left: 30 },   // F line (0px)
                    { clef: 'bass', top: 10, left: 40 }     // F line (10px)
                ],
                'C#': [
                    { clef: 'treble', top: 15, left: 30 },  // C space (15px)
                    { clef: 'bass', top: 25, left: 40 }     // C space (25px)
                ],
                'G#': [
                    { clef: 'treble', top: 30, left: 30 },  // G line (30px)
                    { clef: 'bass', top: 5, left: 40 }      // G space (5px)
                ],
                'D#': [
                    { clef: 'treble', top: 10, left: 30 },  // D line (10px)
                    { clef: 'bass', top: 20, left: 40 }     // D line (20px)
                ],
                'A#': [
                    { clef: 'treble', top: 25, left: 30 },  // A space (25px)
                    { clef: 'bass', top: 0, left: 40 }      // A line (0px)
                ],
                'E#': [
                    { clef: 'treble', top: 5, left: 30 },   // E space (5px)
                    { clef: 'bass', top: 15, left: 40 }     // E space (15px)
                ],
                'B#': [
                    { clef: 'treble', top: 20, left: 30 },  // B line (20px)
                    { clef: 'bass', top: 30, left: 40 }     // B line (30px)
                ],
                
                // Flats
                'Bb': [
                    { clef: 'treble', top: 20, left: 30 },  // B line (20px)
                    { clef: 'bass', top: 30, left: 40 }     // B line (30px)
                ],
                'Eb': [
                    { clef: 'treble', top: 5, left: 30 },   // E space (5px)
                    { clef: 'bass', top: 15, left: 40 }     // E space (15px)
                ],
                'Ab': [
                    { clef: 'treble', top: 25, left: 30 },  // A space (25px)
                    { clef: 'bass', top: 0, left: 40 }      // A line (0px)
                ],
                'Db': [
                    { clef: 'treble', top: 10, left: 30 },  // D line (10px)
                    { clef: 'bass', top: 20, left: 40 }     // D line (20px)
                ],
                'Gb': [
                    { clef: 'treble', top: 30, left: 30 },  // G line (30px)
                    { clef: 'bass', top: 5, left: 40 }      // G space (5px)
                ],
                'Cb': [
                    { clef: 'treble', top: 15, left: 30 },  // C space (15px)
                    { clef: 'bass', top: 25, left: 40 }     // C space (25px)
                ],
                'Fb': [
                    { clef: 'treble', top: 0, left: 30 },   // F line (0px)
                    { clef: 'bass', top: 10, left: 40 }     // F line (10px)
                ]
            };
            
            scaleAccidentals.forEach((accidental, index) => {
                const positions = miniAccidentalPositions[accidental];
                if (!positions) return;
                
                positions.forEach(position => {
                    const accidentalElement = document.createElement('div');
                    accidentalElement.style.position = 'absolute';
                    accidentalElement.style.fontSize = '14px';
                    accidentalElement.style.color = '#666';
                    accidentalElement.style.fontWeight = 'bold';
                    accidentalElement.style.left = (position.left + (index * 8)) + 'px';
                    accidentalElement.style.top = position.top + 'px';
                    accidentalElement.style.transform = 'translateY(-50%)';
                    
                    if (accidental.includes('#')) {
                        accidentalElement.textContent = '♯';
                    } else {
                        accidentalElement.textContent = '♭';
                    }
                    
                    // Append to the appropriate staff container
                    if (position.clef === 'treble') {
                        trebleStaff.appendChild(accidentalElement);
                    } else {
                        bassStaff.appendChild(accidentalElement);
                    }
                });
            });
        }



        function displayKeySignature(selectedScale) {

            // Clear existing accidentals
            const existingAccidentals = document.querySelectorAll('.key-signature-accidental');
            existingAccidentals.forEach(acc => acc.remove());
            
            const scaleAccidentals = SCALE_DEFINITIONS[selectedScale] || [];
            const staffArea = document.querySelector('.staff-area');
            const isLandscapeChordMode = document.body.classList.contains('landscape-mode-active');
            
            // FIXED: Get the correct container
            const container = isLandscapeChordMode ? 
                staffArea.querySelector('.staff-inner') || staffArea : 
                staffArea;
            
            scaleAccidentals.forEach((accidental, index) => {
                const positions = ACCIDENTAL_POSITIONS[accidental];
                if (!positions) return;
                
                positions.forEach(position => {
                    const accidentalElement = document.createElement('div');
                    accidentalElement.className = 'key-signature-accidental';
                    accidentalElement.style.position = 'absolute';
                    
                    if (accidental.includes('#')) {
                        accidentalElement.style.fontSize = '17px';
                        accidentalElement.style.transform = 'translateY(-50%)';
                        accidentalElement.textContent = '♯';
                    } else {
                        accidentalElement.style.fontSize = '20px';
                        accidentalElement.style.transform = 'translateY(-60%)';
                        accidentalElement.textContent = '♭';
                    }
                    
                    accidentalElement.style.color = '#333';
                    accidentalElement.style.zIndex = '5';
                    accidentalElement.style.fontWeight = 'bold';
                    accidentalElement.style.left = (60 + (index * 8)) + 'px';
                    
                    // FIXED: Use pixel positioning in landscape mode
                    if (isLandscapeChordMode) {
                        accidentalElement.style.top = `${(position.position - 1) * (280 / 48)}px`;
                    } else {
                        accidentalElement.style.top = `calc(${position.position - 1} * (100% / 48))`;
                    }
                    
                    container.appendChild(accidentalElement);
                });
            });
        }

        // Piano sound setup
        let piano = null; // Declare globally but initialize later

        async function initializePiano() {
 
            try {
                const noteFiles = {
                    A0: "A0.mp3", C1: "C1.mp3", "D#1": "Ds1.mp3", "F#1": "Fs1.mp3",
                    A1: "A1.mp3", C2: "C2.mp3", "D#2": "Ds2.mp3", "F#2": "Fs2.mp3",
                    A2: "A2.mp3", C3: "C3.mp3", "D#3": "Ds3.mp3", "F#3": "Fs3.mp3",
                    A3: "A3.mp3", C4: "C4.mp3", "D#4": "Ds4.mp3", "F#4": "Fs4.mp3",
                    A4: "A4.mp3", C5: "C5.mp3", "D#5": "Ds5.mp3", "F#5": "Fs5.mp3",
                    A5: "A5.mp3", C6: "C6.mp3", "D#6": "Ds6.mp3", "F#6": "Fs6.mp3",
                    A6: "A6.mp3"
                };
                
                if (window.Capacitor && window.Capacitor.isNativePlatform()) {
                    
                    const buffers = {};
                    
                    for (const [note, file] of Object.entries(noteFiles)) {
                        try {
                            const response = await fetch(`assets/audio/salamander/${file}`);
                            const arrayBuffer = await response.arrayBuffer();
                            const audioBuffer = await Tone.context.decodeAudioData(arrayBuffer);
                            buffers[note] = audioBuffer;
                        } catch (err) {
                            console.error(`❌ Failed to load ${note}:`, err);
                        }
                    }
                    
                    piano = new Tone.Sampler(buffers).toDestination();
                    console.log("✅ Piano initialized with buffers!");
                } else {
                    // Regular web loading
                    piano = new Tone.Sampler({
                        urls: noteFiles,
                        baseUrl: "assets/audio/salamander/"
                    }).toDestination();
                }
            } catch (error) {
                console.error("❌ Piano initialization failed:", error);
            }
        }

        // Reduce audio latency for better responsiveness
        Tone.context.lookAhead = 0;
        Tone.context.latencyHint = "interactive";

        // Log latency info for debugging
        if (Tone.context.rawContext) {
            console.log('Audio context base latency:', Tone.context.rawContext.baseLatency);
        }

        function convertToToneFormat(note, octave, hand = '') {
            let toneNote = note.replace('#', '#').replace('b', 'b');
            return toneNote + octave;
        }

        async function startAudio() {
            if (Tone.context.state !== 'running') {
                await Tone.start();
                console.log('Audio context started');
            }
        }

        function playPianoSound(note, octave) {
            // Check if sound is enabled (we need to make soundEnabled global)
            if (!window.soundEnabled) return;

            if (piano) {
                const toneFormat = convertToToneFormat(note, octave);
                const equivalents = getEnharmonicEquivalents(note);
                
                piano.triggerAttackRelease(toneFormat, "1n");
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initGame);
    </script>

    <script>
        
        const urlParams = new URLSearchParams(window.location.search);
        const gameMode = urlParams.get('mode') || 'free';
        const isPremium = gameMode === 'premium' || localStorage.getItem('premiumPurchased') === 'true';

        if (!isPremium) {
            document.getElementById('scalesToggle').disabled = true;
            document.getElementById('chordsToggle').disabled = true;
            document.getElementById('stillToggle').disabled = true;
            document.getElementById('regionSelect').disabled = true;
            document.getElementById('scale').disabled = true;

            document.querySelector('.scales-label').style.opacity = '0.5';
            document.querySelector('.chords-label').style.opacity = '0.5';
            document.querySelector('.still-label').style.opacity = '0.5';
        }
    </script>

    <script>
        
        // REPLACE YOUR ENTIRE LandscapeChordModule WITH THIS:
        const LandscapeChordModule = {
            config: {
                isLandscape: false,
                isChordsActive: false,
                currentChordOctaves: { lower: 3, upper: 4 },
                twoOctaveMode: false,
                debugMode: false
            },
            
            init() {
                console.log("🚀 Initializing LandscapeChordModule");
                this.setupOrientationListener();
                this.modifyPianoCreation();
            },
            

            detectOrientation() {
                const wasLandscape = this.config.isLandscape;
                const wasTwoOctave = this.config.twoOctaveMode;
                
                // Enhanced landscape detection
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;
                const isLandscape = aspectRatio > 1.3 && height < 500; // More specific criteria
                
                
                this.config.isLandscape = isLandscape;
                this.config.twoOctaveMode = isLandscape; // <-- SIMPLIFIED: Just use landscape detection
                
                this.updateDebugInfo();
                
                // Only update if something changed
                if (wasLandscape !== isLandscape || wasTwoOctave !== this.config.twoOctaveMode) {
                    this.updateLayout();
                }
            },
            
            updateDebugInfo() {
                if (!this.config.debugMode) return;
                
                const debugInfo = document.getElementById('debugInfo');
                if (debugInfo) {
                    const orientationInfo = document.getElementById('orientationInfo');
                    const viewportInfo = document.getElementById('viewportInfo');
                    const chordModeInfo = document.getElementById('chordModeInfo');
                    const twoOctaveInfo = document.getElementById('twoOctaveInfo');
                    
                    if (orientationInfo) orientationInfo.textContent = this.config.isLandscape ? 'Landscape' : 'Portrait';
                    if (viewportInfo) viewportInfo.textContent = `${window.innerWidth}x${window.innerHeight}`;
                    if (chordModeInfo) chordModeInfo.textContent = this.config.isChordsActive ? 'Active' : 'Inactive';
                    if (twoOctaveInfo) twoOctaveInfo.textContent = this.config.twoOctaveMode ? 'Active' : 'Inactive';
                }
            },
            
            setupOrientationListener() {
                // Multiple event listeners for better coverage
                window.addEventListener('orientationchange', () => {
                    console.log("📱 Orientation change event fired");
                    setTimeout(() => this.detectOrientation(), 200);
                });
                
                window.addEventListener('resize', () => {
                    console.log("📐 Resize event fired");
                    this.detectOrientation();
                });
                
                // Also check periodically in case events are missed
                setInterval(() => {
                    this.detectOrientation();
                }, 1000);
            },
            

            updateLayout() {
                console.log("🔄 Updating layout - Two octave mode:", this.config.twoOctaveMode);
                const body = document.body;
                
                if (this.config.twoOctaveMode) {
                    body.classList.add('landscape-mode-active');
                    this.createTwoOctavePiano();
                    console.log("✅ Activated two-octave piano");
                    
                    // Wrap staff content and initialize clef switching
                    setTimeout(() => {
                        wrapStaffContent();
                        ClefSwitchingModule.init();
                        console.log('🎵 Initialized clef switching in landscape mode');
                    }, 100);
                } else {
                    body.classList.remove('landscape-mode-active', 'treble-view', 'bass-view');
                    
                    // FIX: Actually recreate the single octave piano instead of calling undefined function
                    createPianoKeys(); // <-- This calls the original createPianoKeys function
                    
                    // Remove clef button
                    if (ClefSwitchingModule.button) {
                        ClefSwitchingModule.button.remove();
                        ClefSwitchingModule.button = null;
                    }
                    console.log("✅ Activated single-octave piano");
                }
            },
                        
            // Modify the existing createPianoKeys function
            modifyPianoCreation() {
                // Don't override the function, just call it when needed
                console.log("🎹 Piano creation modified");
            },
            
            createTwoOctavePiano() {
                const pianoKeys = document.getElementById('pianoKeys');
                if (!pianoKeys) {
                    console.log("❌ Piano keys container not found");
                    return;
                }
                
                pianoKeys.innerHTML = '';
                
                // Add controls (same as single octave)
                this.addPianoControls(pianoKeys);
                
                // Determine octaves based on current chord
                const lowerOctave = this.config.currentChordOctaves.lower;
                const upperOctave = this.config.currentChordOctaves.upper;
                
                // Create two octaves
                this.createOctave(pianoKeys, lowerOctave, 'lower');
                this.createOctave(pianoKeys, upperOctave, 'upper');
                
                // Add octave indicators
                this.addOctaveIndicators(pianoKeys, lowerOctave, upperOctave);
                
                console.log(`🎹 Created two-octave piano: C${lowerOctave} and C${upperOctave}`);
            },
            
            createOctave(container, octave, position) {
                const WHITE_KEYS = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                
                WHITE_KEYS.forEach(note => {
                    const key = document.createElement('div');
                    key.className = 'key white-key';
                    key.textContent = note;
                    key.dataset.note = note;
                    key.dataset.octave = octave;
                    
                    key.addEventListener('click', () => {
                        playPianoKey(note);
                        
                    });
                    
                    key.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        key.classList.add('pressed');
                        playPianoKey(note);
                        playPianoSound(note, octave);
                    });
                    
                    key.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        key.classList.remove('pressed');
                    });
                    
                    container.appendChild(key);
                    
                    // Add black keys
                    if (['C', 'D', 'F', 'G', 'A'].includes(note)) {
                        const blackNote = note + '#';
                        const blackKey = document.createElement('div');
                        blackKey.className = 'key black-key';
                        
                        const enharmonics = getEnharmonicEquivalents(blackNote);
                        if (enharmonics.length > 1) {
                            blackKey.innerHTML = enharmonics.join('<br>');
                        } else {
                            blackKey.textContent = blackNote;
                        }
                        
                        blackKey.dataset.note = blackNote;
                        blackKey.dataset.octave = octave;
                        
                        blackKey.addEventListener('click', () => {
                            playPianoKey(blackNote);
                            
                        });
                        
                        blackKey.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            blackKey.classList.add('pressed');
                            playPianoKey(blackNote);
                            playPianoSound(blackNote, octave);
                        });
                        
                        blackKey.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            blackKey.classList.remove('pressed');
                        });
                        
                        container.appendChild(blackKey);
                    }
                });
            },
            
            addPianoControls(container) {
                // Key labels toggle
                const labelToggle = document.createElement('div');
                labelToggle.className = 'key-labels-toggle';
                labelToggle.innerHTML = '👁';
                labelToggle.title = 'Toggle key labels';
                
                let labelsVisible = false;
                labelToggle.addEventListener('click', () => {
                    labelsVisible = !labelsVisible;
                    const allKeys = container.querySelectorAll('.key');
                    allKeys.forEach(key => {
                        key.style.color = labelsVisible ? 
                            (key.classList.contains('white-key') ? 'black' : 'white') : 
                            'transparent';
                    });
                    labelToggle.style.opacity = labelsVisible ? '1' : '0.5';
                });
                
                container.appendChild(labelToggle);
                
                // Support notes toggle
                const supportToggle = document.createElement('div');
                supportToggle.className = 'support-notes-toggle';
                supportToggle.innerHTML = '-c-';
                supportToggle.title = 'Toggle support notes';
                
                let supportVisible = false;
                supportToggle.addEventListener('click', () => {
                    supportVisible = !supportVisible;
                    const supportContainer = document.getElementById('supportNotesContainer');
                    if (supportVisible) {
                        supportContainer.classList.add('active');
                        createSupportNotes();
                    } else {
                        supportContainer.classList.remove('active');
                    }
                    supportToggle.style.opacity = supportVisible ? '1' : '0.5';
                });
                
                container.appendChild(supportToggle);
                
                // Sound toggle
                const soundToggle = document.createElement('div');
                soundToggle.className = 'sound-toggle';
                soundToggle.innerHTML = window.soundEnabled ? '♪' : '🔇';
                soundToggle.title = 'Toggle sound on/off';
                
                soundToggle.addEventListener('click', () => {
                    window.soundEnabled = !window.soundEnabled;
                    soundToggle.innerHTML = window.soundEnabled ? '♪' : '🔇';
                });
                
                container.appendChild(soundToggle);
            },
            
            addOctaveIndicators(container, lower, upper) {
                const lowerIndicator = document.createElement('div');
                lowerIndicator.className = 'octave-indicator lower';
                lowerIndicator.textContent = `C${lower}`;
                container.appendChild(lowerIndicator);
                
                const upperIndicator = document.createElement('div');
                upperIndicator.className = 'octave-indicator upper';
                upperIndicator.textContent = `C${upper}`;
                container.appendChild(upperIndicator);
            },
            
            updateChordOctaves(chordData) {
                if (!this.config.twoOctaveMode) return;
                
                // Find the lowest note in the chord
                const lowestNote = chordData.notes.reduce((lowest, note) => {
                    return note.octave < lowest.octave ? note : lowest;
                });
                
                // Set octaves intelligently
                this.config.currentChordOctaves = {
                    lower: Math.max(2, lowestNote.octave - 1),
                    upper: lowestNote.octave
                };
                
                // Recreate piano with new octaves
                if (this.config.twoOctaveMode) {
                    this.createTwoOctavePiano();
                }
            },
            
            restoreSingleOctavePiano() {
                // Simply call the global createPianoKeys function to restore single octave
                if (typeof createPianoKeys === 'function') {
                    createPianoKeys();
                    console.log("✅ Restored single octave piano");
                } else {
                    console.error("❌ createPianoKeys function not found");
                }
            }

        };

        // Landscape panels module
        const LandscapePanelsModule = {
            leftPanel: null,
            rightPanel: null,
            
            init() {
                // Listen for landscape mode changes
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.target.classList.contains('landscape-mode-active')) {
                            this.createPanels();
                        } else {
                            this.removePanels();
                        }
                    });
                });
                
                observer.observe(document.body, {
                    attributes: true,
                    attributeFilter: ['class']
                });
                
                // Check initial state
                if (document.body.classList.contains('landscape-mode-active')) {
                    this.createPanels();
                }
            },
            
            createPanels() {
                // Remove existing panels if any
                this.removePanels();
                
                // Create left panel for toggles
                this.leftPanel = document.createElement('div');
                this.leftPanel.className = 'left-panel';
                
                const toggleColumn = document.createElement('div');
                toggleColumn.className = 'toggle-column';
                
                // Add toggles in order: notes, scales, chords, move, still
                const toggles = [
                    { id: 'notesToggle', label: 'Notes', class: 'notes-label' },
                    { id: 'scalesToggle', label: 'Scales', class: 'scales-label' },
                    { id: 'chordsToggle', label: 'Chords', class: 'chords-label' },
                    { id: 'gameModeToggle', label: 'Move', class: 'move-label' },
                    { id: 'stillToggle', label: 'Still', class: 'still-label' }
                ];
                
                toggles.forEach(toggle => {
                    const row = document.createElement('div');
                    row.className = 'toggle-row';
                    
                    const label = document.createElement('span');
                    label.className = `toggle-label-text ${toggle.class}`;
                    label.textContent = toggle.label;
                    
                    const switchContainer = document.createElement('div');
                    switchContainer.className = 'toggle-switch';
                    
                    const input = document.getElementById(toggle.id);
                    const newInput = input.cloneNode(true);
                    newInput.id = toggle.id + '_landscape';
                    
                    // Sync with original input
                    newInput.checked = input.checked;
                    newInput.disabled = input.disabled;
                    
                    // Sync changes back to original
                    newInput.addEventListener('change', () => {
                        input.checked = newInput.checked;
                        input.dispatchEvent(new Event('change'));
                    });
                    
                    // Listen for original changes
                    const syncFromOriginal = () => {
                        newInput.checked = input.checked;
                        newInput.disabled = input.disabled;
                    };
                    
                    input.addEventListener('change', syncFromOriginal);
                    
                    // Also watch for attribute changes (disabled state)
                    const attrObserver = new MutationObserver(syncFromOriginal);
                    attrObserver.observe(input, { attributes: true });
                    
                    const labelEl = document.createElement('label');
                    labelEl.className = 'toggle-slider-label';
                    labelEl.htmlFor = newInput.id;
                    labelEl.innerHTML = '<span class="toggle-slider"></span>';
                    
                    switchContainer.appendChild(newInput);
                    switchContainer.appendChild(labelEl);
                    
                    row.appendChild(label);
                    row.appendChild(switchContainer);
                    toggleColumn.appendChild(row);
                });
                
                this.leftPanel.appendChild(toggleColumn);
                document.body.appendChild(this.leftPanel);
                
                // Create right panel for dropdowns
                this.rightPanel = document.createElement('div');
                this.rightPanel.className = 'right-panel';
                
                const dropdownColumn = document.createElement('div');
                dropdownColumn.className = 'dropdown-column';
                
                // Add dropdowns in order: Level, Key (Region removed)
                const dropdowns = [
                    { id: 'levelDropdown', select: 'difficultySelect' },
                    { id: 'keyDropdown', select: 'scale' }
                ];
                
                dropdowns.forEach(dropdown => {
                    const originalDropdown = document.getElementById(dropdown.id);
                    if (!originalDropdown) return;
                    
                    const row = document.createElement('div');
                    row.className = 'dropdown-row';
                    row.id = dropdown.id + '_landscape';
                    
                    const text = document.createElement('div');
                    text.className = 'dropdown-text';
                    text.innerHTML = originalDropdown.querySelector('.dropdown-text').innerHTML + ' <span class="dropdown-arrow">›</span>';
                    
                    // Copy functionality
                    row.addEventListener('click', () => {
                        if (!gameState.isPlaying) {
                            originalDropdown.click();
                        }
                    });
                    
                    // Listen for updates to original
                    const observer = new MutationObserver(() => {
                        text.innerHTML = originalDropdown.querySelector('.dropdown-text').innerHTML + ' <span class="dropdown-arrow">›</span>';
                    });
                    
                    observer.observe(originalDropdown.querySelector('.dropdown-text'), {
                        childList: true,
                        characterData: true,
                        subtree: true
                    });
                    
                    row.appendChild(text);
                    dropdownColumn.appendChild(row);
                });
                
                this.rightPanel.appendChild(dropdownColumn);
                document.body.appendChild(this.rightPanel);
                
                // Update label colors based on current state
                this.updateLabelColors();
            },
            
            removePanels() {
                if (this.leftPanel) {
                    this.leftPanel.remove();
                    this.leftPanel = null;
                }
                if (this.rightPanel) {
                    this.rightPanel.remove();
                    this.rightPanel = null;
                }
            },
            
            updateLabelColors() {
                if (!this.leftPanel) return;
                
                // Update all label colors to match original state
                const labelMappings = [
                    { original: '.notes-label', landscape: '.left-panel .notes-label' },
                    { original: '.scales-label', landscape: '.left-panel .scales-label' },
                    { original: '.chords-label', landscape: '.left-panel .chords-label' },
                    { original: '.move-label', landscape: '.left-panel .move-label' },
                    { original: '.still-label', landscape: '.left-panel .still-label' }
                ];
                
                labelMappings.forEach(mapping => {
                    const originalLabel = document.querySelector(mapping.original);
                    const landscapeLabel = document.querySelector(mapping.landscape);
                    if (originalLabel && landscapeLabel) {
                        landscapeLabel.style.color = window.getComputedStyle(originalLabel).color;
                    }
                });
            }
        };

        // Initialize the landscape panels module
        document.addEventListener('DOMContentLoaded', () => {
            LandscapePanelsModule.init();
        });

        // Listen for label color changes
        const labelObserver = new MutationObserver(() => {
            LandscapePanelsModule.updateLabelColors();
        });

        // Observe all labels for style changes
        document.addEventListener('DOMContentLoaded', () => {
            const labels = document.querySelectorAll('.toggle-label-text');
            labels.forEach(label => {
                labelObserver.observe(label, {
                    attributes: true,
                    attributeFilter: ['style']
                });
            });
        });

        
        const ClefSwitchingModule = {
            currentClef: 'treble',
            button: null,
            
            init() {
                console.log('🎵 Initializing ClefSwitchingModule');
                // Wrap staff content first
                wrapStaffContent();
                this.createClefToggleButton();
                this.setDefaultView();
            },
            
            createClefToggleButton() {
                // Remove existing button if any
                if (this.button) {
                    this.button.remove();
                }
                
                // Create new button
                this.button = document.createElement('div');
                this.button.className = 'clef-toggle-button';
                this.button.id = 'clefToggleButton';
                this.button.innerHTML = '𝄢'; // Bass clef symbol
                this.button.title = 'Switch to Bass Clef';
                
                // Add click handler
                this.button.addEventListener('click', () => {
                    this.toggleClef();
                });
                
                // Add to game container instead of staff area
                const gameContainer = document.querySelector('.game-container');
                if (gameContainer) {
                    gameContainer.appendChild(this.button);
                    console.log('✅ Clef toggle button created and added to game container');
                }
            },
            
            toggleClef() {
                const body = document.body;
                
                if (this.currentClef === 'treble') {
                    // Switch to bass
                    this.currentClef = 'bass';
                    body.classList.remove('treble-view');
                    body.classList.add('bass-view');
                    this.button.innerHTML = '𝄞'; // Treble clef symbol
                    this.button.title = 'Switch to Treble Clef';
                    
                    // Update game state for bass region
                    if (window.gameState) {
                        window.gameState.selectedRegions = ['bass', 'middle', 'below'];
                    }
                    
                    console.log('🎵 Switched to Bass Clef view');
                } else {
                    // Switch to treble
                    this.currentClef = 'treble';
                    body.classList.remove('bass-view');
                    body.classList.add('treble-view');
                    this.button.innerHTML = '𝄢'; // Bass clef symbol
                    this.button.title = 'Switch to Bass Clef';
                    
                    // Update game state for treble region
                    if (window.gameState) {
                        window.gameState.selectedRegions = ['above', 'treble', 'middle'];
                    }
                    
                    console.log('🎵 Switched to Treble Clef view');
                }
            },
            
            setDefaultView() {
                const body = document.body;
                this.currentClef = 'treble';
                body.classList.add('treble-view');
                body.classList.remove('bass-view');
                
                if (window.gameState) {
                    window.gameState.selectedRegions = ['above', 'treble', 'middle'];
                }
                
                if (this.button) {
                    this.button.innerHTML = '𝄢';
                    this.button.title = 'Switch to Bass Clef';
                }
                
                console.log('🎵 Set default treble view');
            },
            
            enableButton() {
                if (this.button) {
                    this.button.classList.remove('disabled');
                    this.button.style.pointerEvents = 'auto';
                    this.button.style.opacity = '1';
                }
            },
            
            disableButton() {
                if (this.button) {
                    this.button.classList.add('disabled');
                    this.button.style.pointerEvents = 'none';
                    this.button.style.opacity = '0.5';
                }
            }
        };

        // Test function for debugging
        window.testClefSwitch = () => {
            console.log('🧪 Testing clef switch...');
            console.log('Current clef:', ClefSwitchingModule.currentClef);
            ClefSwitchingModule.toggleClef();
        };


        // Initialize the module - MAKE SURE THIS RUNS AFTER DOM IS LOADED
        document.addEventListener('DOMContentLoaded', () => {
            console.log("🚀 DOM loaded, initializing LandscapeChordModule...");
            LandscapeChordModule.init();
        });

        // Test function you can call from console
        window.testLandscapeMode = () => {
            console.log("🧪 Testing landscape mode...");
            console.log("Current config:", LandscapeChordModule.config);
            LandscapeChordModule.detectOrientation();
        };

        // Initialize the module
        LandscapeChordModule.init();

        // Modify your generateChord function to update octaves
        const originalGenerateChord = window.generateChord;
        window.generateChord = function() {
            const result = originalGenerateChord();
            
            // Update piano octaves for this chord
            if (result && result.notes) {
                LandscapeChordModule.updateChordOctaves(result);
            }
            
            return result;
        };

        // Ensure proper initialization on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                LandscapeChordModule.detectOrientation();
            }, 100);
        });
    </script>

</body>
</html>
